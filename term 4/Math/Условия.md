# Потоки и паросочетания

## A. Массовая проверка простоты
  ограничение по времени на тест: 1.5 секунд
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
 Целое число **_p_ ≥ 2** является простым, если у него нет делителей кроме 1 и **p**. Необходимо для всех чисел во входном файле проверить простые они или нет.
  
### Входные данные

В первой строке задано число **_n_** (**2 ≤ _n_ ≤ 500000**). В следующих **_n_** строках заданы числа **_ai_** (**2 ≤ _ai_ ≤ 2*10^7**), которые нужно проверить на простоту

### Выходные данные

Для каждого числа во входном файле выведите на отдельной строке «YES» или «NO» в зависимости от того, простое оно или нет.

### Примеры

**входные данные**
```c++
4
60
14
3
55
```
**выходные данные**
```c++
NO
NO
YES
NO
```

### [Решение](A.cpp)


## B. Массовое разложение на множители

  ограничение по времени на тест: 0.5 секунд
  
  ограничение по памяти на тест: 64 мегабайта
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
 Дано много чисел. Требуется разложить их все на простые множители.
  
### Входные данные

В первой строке задано число _n_ (2 ≤ _n_ ≤ 300000). В следующих _n_ строках заданы числа _ai_ (2 ≤ _ai_ ≤ 10^6), которые нужно разложить на множители.

### Выходные данные

Для каждого числа выведите в отдельной строке разложение на простые множители в порядке возрастания множителей.

### Примеры

**входные данные**
```c++
4
60
14
3
55
```
**выходные данные**
```c++
2 2 3 5 
2 7 
3 
5 11 
```

### [Решение](B.cpp)


## C. Большая проверка на простоту

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 64 мегабайта
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
  Дано _n_ натуральных чисел _ai_. Определите для каждого числа, является ли оно простым.

### Входные данные

Программа получает на вход число _n_, 1 ≤ _n_ ≤ 1000 и далее n чисел _ai_, 1 ≤ _ai_ ≤ 10^18.

### Выходные данные

Если число _ai_ простое, программа должна вывести YES, для составного числа программа должна вывести NO.

### Примеры

**входные данные**
```c++
4
1
5
10
239
```
**выходные данные**
```c++
NO
YES
NO
YES
```

### [Решение](C.cpp)


## D. Китайская теорема

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 64 мегабайта
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
 Решите в целых числах систему уравнений
 
```c++
    x = a (mod n)
    x = b (mod n)
```

 Гарантируется, что _n_ и _m_ взаимно просты. Среди решений следует выбрать наименьшее неотрицательное число.

### Входные данные

Входной файл содержит четыре целых числа _a_, _b_, _n_ и _m_ (1 ≤ _n_, _m_ ≤ 10^6, 0 ≤ _a_ < _n_, 0 ≤ _b_ < _m_).

### Выходные данные

В выходной файл выведите искомое наименьшее неотрицательное число _x_.

### Примеры

**входные данные**
```c++
1 0 2 3
```
**выходные данные**
```c++
3
```

**входные данные**
```c++
3 2 5 9
```
**выходные данные**
```c++
38
```

### [Решение](D.cpp)


## E. Взлом RSA

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 64 мегабайта
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
В 1977 году Ronald Linn Rivest, Adi Shamir и Leonard Adleman предложили новую криптографическую схему RSA, используемую до сих пор. RSA является криптосистемой с открытым ключом: зашифровать сообщение может кто угодно, знающий общеизвестный открытый ключ, а расшифровать сообщение — только тот, кто знает специальный секретный ключ.

Желающий использовать систему RSA для получения сообщений должен сгенерировать два простых числа p и q, вычислить n = pq и сгенерировать два числа _e_ и _d_ такие, что {_ed_ ≡ 1 ± _od_{(_p_ - 1)(_q_ - 1)}} (заметим, что {(_p_ - 1)(_q_ - 1) = φ(_n_)}). Числа _n_ и _e_ составляют открытый ключ и являются общеизвестными. Число _d_ является секретным ключом, также необходимо хранить в тайне и разложение числа _n_ на простые множители, так как это позволяет вычислить секретный ключ _d_.

Сообщениями в системе RSA являются числа из **Z**. Пусть _M_ — исходное сообщение. Для его шифрования вычисляется значение **_C_ = _M_^_e_ mod _n_**  (для этого необходимо только знание открытого ключа). Полученное зашифрованное сообщение _C_ передается по каналу связи. Для его расшифровки необходимо вычислить значение **M = _C_^_d_ mod _n_**, а для этого необходимо знание секретного ключа.

Вы перехватили зашифрованное сообщение _C_ и знаете только открытый ключ: числа _n_ и _e_. "Взломайте" RSA — расшифруйте сообщение на основе только этих данных.

### Входные данные

Программа получает на вход три натуральных числа: _n_, _e_, _C_, _n_ ≤ 10^9, _e_ ≤ 10^9, _C_ < _n_. Числа _n_ и _e_ являются частью какой-то реальной схемы RSA, т.е. _n_ является произведением двух простых и e взаимно просто с φ(_n_). Число _C_ является результатом шифрования некоторого сообщения _M_.

### Выходные данные

Выведите одно число _M_ (0 ≤ _M_ < _n_), которое было зашифровано такой криптосхемой.


### Примеры

**входные данные**
```c++
143
113
41
```
**выходные данные**
```c++
123
```

**входные данные**
```c++
9173503
3
4051753
```
**выходные данные**
```c++
111111
```

### [Решение](E.cpp)


## F. Задача для второклассника

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Вам даны два числа. Необходимо найти их произведение.

### Входные данные

Входные данные состоят из двух строк, на каждой из которых находится целое одно **целое** число, длина которого не превосходит двухсот пятидесяти тысяч символо

### Выходные данные

Выведите произведение данных чисел.

### Примеры

**входные данные**
```c++
2
2
```
**выходные данные**
```c++
4
```

**входные данные**
```c++
1
-1
```
**выходные данные**
```c++
-1
```

### [Решение](F.hs)
