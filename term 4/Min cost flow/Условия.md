# Поток минимальной стоимости

## A. Максимальный поток минимальной стоимости

  ограничение по времени на тест: 5 секунд
  
  ограничение по памяти на тест: 512 мегабайт
  
  **ввод: mincost.in**
  
  **вывод: mincost.out**
  
Задан ориентированный граф, каждое ребро которого обладает пропускной способностью и стоимостью. Найдите максимальный поток минимальной стоимости из вершины с номером 1 в вершину с номером _n_.  

### Входные данные

Первая строка входного файла содержит _n_ и _m_ — количество вершин и количество ребер графа (2 ≤ _n_ ≤ 100, 1 ≤ _m_ ≤ 1000). Следующие _m_ строк содержат по четыре целых числа числа: номера вершин, которые соединяет соответствующее ребро графа, его пропускную способность и его стоимость. Пропускные способности и стоимости не превосходят 10^5.

### Выходные данные

В выходной файл выведите одно число — цену максимального потока минимальной стоимости из вершины с номером 1 в вершину с номером _n_. Ответ не превышает 2^63 - 1. Гарантируется, что в графе нет циклов отрицательной стоимости.

### Примеры

**входные данные**
```c++
4 5
1 2 1 2
1 3 2 2
3 2 1 1
2 4 2 1
3 4 2 3
```
**выходные данные**
```c++
12
```

### [Решение](A.cpp)


## B. Задача о назначениях

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дана целочисленная матрица _C_ размера _n_ × _n_. Требуется выбрать _n_ ячеек так, чтобы в каждой строке и каждом столбце была выбрана ровно одна ячейка, а сумма значений в выбранных ячейках была минимальна. 

### Входные данные

Первая строка входного файла содержит _n_ (2 ≤ _n_ ≤ 300). Каждая из последующих _n_ строк содержит по _n_ чисел: _Cij_ Все значения во входном файле неотрицательны и не превосходят 10^6.

### Выходные данные

В первую строку выходного файла выведите одно число — искомая минимизуруемая величина. Далее выведите _n_ строк по два числа в каждой — номер строки и столбца клетки, участвующей в оптимальном назначении.

### Примеры

**входные данные**
```c++
3
3 2 1
1 3 2
2 1 3
```
**выходные данные**
```c++
3
2 1
3 2
1 3
```

### [Решение](B.cpp)


## C. Costly Labels

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дано дерево без корня с _N_ вершинами, являющееся связным, неориентированным графом с _N_ вершинами, пронумерованными с 1 до _N_, и _N_ - 1 ребрами. _i_-е ребро соединяет вершины _Ai_ и _Bi_.

Вы хотите отметить каждую вершину числом от 1 до _K_, включительно так, чтобы потратить как можно меньше денег. Отметить _i_-ю вершину числом _j_, стоит _Ci_, _j_ долларов.

Также, после того, как все дерево было отмечено, вы должны заплатить еще _P_ долларов за каждую вершину, которая имеет как минимум одну пару соседей, отмеченных одним числом. Другими словами, за каждую вершину _u_, вы должны заплатить _P_ долларов если существуют две другие вершины _v_ и _w_, смежные с _u_, такие, что числа, которыми отмечены _v_ и _w_, одинаковы (заметим, что число, которым отмечена _u_, не важно). Вы платите штраф в _P_ долларов один раз для данной центральной вершины _u_, даже если существует несколько пар соседей, удовлетворяющих вышеописанному условию.

Какая минимальная стоимость (в долларах) отметки всех _N_ вершин?

### Входные данные

В первой строчке содержатся натуральные числа _N_ (1 ≤ _N_ ≤ 1000), _K_ (1 ≤ _K_ ≤ 30), и _P_ (0 ≤ _P_ ≤ 10^6), отделенные пробелом. Затем, _N_ строчек, _i_-я из которых содержит разделенные пробелом числа от _Ci_, 1 до _Ci_, _K_ (0 ≤ _Ci_, _j_ ≤ 10^6). Далее, _N_ - 1 строчка, _i_-я из которых содержит два разделенных пробелом числа _Ai_ и _Bi_ (1 ≤ _Ai_, _Bi_ ≤ _N_).

### Выходные данные

Выведите минимальную стоимость отметки всех вершин дерева.

### Примеры

**входные данные**
```c++
1 1 1
111
```
**выходные данные**
```c++
111
```

**входные данные**
```c++
3 1 8
1
2
4
1 2
2 3
```
**выходные данные**
```c++
15
```

**входные данные**
```c++
3 2 10
4 7
8 9
2 3
1 2
2 3
```
**выходные данные**
```c++
15
```

**входные данные**
```c++
4 2 99
0 1
0 1
0 1
0 0
4 1
2 4
4 3
```
**выходные данные**
```c++
99
```

**входные данные**
```c++
4 3 99
0 1 0
0 1 0
0 1 0
0 0 0
4 1
2 4
4 3
```
**выходные данные**
```c++
1
```

### [Решение](C.cpp)


## D. Камень, ножницы, бумага — 2

  ограничение по времени на тест: 1 секунда
  
  ограничение по памяти на тест: 512 мегабайт
  
  **ввод: rps2.in**
  
  **вывод: rps2.out**
  
Год назад Ростислав с Мирославом играли в камень, ножницы, бумагу на щелбаны. За каждый выигранный раунд победитель ставил один щелбан проигравшему. В случае ничьи щелбаны не ставились. Эта игра запомнилась Мирославу как самая худшая игра в его жизни: всю следующую неделю у него болел лоб.

Воспоминания нахлынули на Мирослава, когда он нашел бумажку с шестью числами — запись с той самой игры. Прошло много времени, и теперь Мирослав может спокойно подумать, почему он проиграл так много раз. Но, к сожалению, он не может посчитать точное количество своих поражений, так как он записал только то, что Ростислав показал камень _r1_ раз, ножницы _s1_ раз и бумагу _p1_ раз, а сам Мирослав показал камень _r2_ раз, ножницы _s2_ раз и бумагу _p2_ раз.

Помогите Мирославу узнать по этим данным, какое минимальное количество щелбанов он мог получить в той самой роковой игре.

Для справки, победитель этой игры определяется по следующим правилам:
• Камень побеждает ножницы («камень затупляет или ломает ножницы»);
• Ножницы побеждают бумагу («ножницы разрезают бумагу»);
• Бумага побеждает камень («бумага накрывает камень»).

Если игроки показали одинаковый знак, то засчитывается ничья.

### Входные данные

В первой строке входных данных три целых числа _r1_, _s1_, _p1_. Во второй строке три целых числа _r2_, _s2_, _p2_.

Все числа неотрицательные и не превышают 10^8, _r1_ + _s1_ + _p1_ = _r2_ + _s2_ + _p2_.

### Выходные данные

Выходные данные должны содержать единственное число  — минимальное количество щелбанов, которые мог получить Мирослав.


### Примеры

**входные данные**
```c++
3 0 0
0 3 0
```
**выходные данные**
```c++
3
```

### [Решение](D.cpp)


## E. Задача коммивояжеров

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  **ввод: rps2.in**
  
  **вывод: rps2.out**
  
Есть _n_ городов. Между городами есть ориентированные дороги, у каждой дороги есть стоимость покупки разрешения на проезд. Мы хотим торговать во всех городах. У нас есть неограниченное кол-во коммивояжеров. Для каждого из них мы должны определить список городов, в которых они будут торговать. Каждый коммивояжер будет объезжать все города из своего списка по циклу (он может по пути заезжать в другие города, но не торговать там). Если два (или более) коммивояжеров будут ездить по одной дороге, то каждому из них мы должны купить разрешение на проезд. Если список у коммивояжера состоит только из одного города, то он либо должен регулярно выезжать из города (тоже по какому-то циклу), либо мы должны купить ему прописку (у каждого города есть цена прописки). Наконец, в любом городе должен торговать только один коммивояжер, иначе предприятием заинтересуется налоговая. Нужно минимизировать издержки.

### Входные данные

В первой строке два числа _n_, _m_ — количество городов и количество дорог (1 ≤ _n_ ≤ 256, 0 ≤ _m_ ≤ _n_(_n_ - 1)).

Во второй строке _n_ чисел _ai_ — цена прописки для города номер _i_ (0 ≤ _ai_ ≤ 10^9).

Затем в m строках описаны дороги. Описание дороги из города _u_ в город _v_ со стоимостью разрешения на проезд c выглядит как _u_ _v_ _cost_ (1 ≤ _u_, _v_ ≤ _n_, _u_ ≠ _v_, 0 ≤ _c_ ≤ 10^9). Гарантируется, что между любой парой городов не более 1 дороги в каждом из направлений.

### Выходные данные

Выведите одно число — минимальную сумму издержек.


### Примеры

**входные данные**
```c++
3 3
30 25 30
1 2 3
2 3 5
3 1 10
```
**выходные данные**
```c++
18
```

### [Решение](E.cpp)
