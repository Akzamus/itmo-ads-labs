# Потоки и паросочетания

## A. Просто поток
  ограничение по времени на тест: 5 секунд
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
 Дана система из узлов и труб, по которым может течь вода. Для каждой трубы известна наибольшая скорость, с которой вода может протекать через нее. Известно, что вода течет по трубам таким образом, что за единицу времени в каждый узел (за исключением двух — источника и стока) втекает ровно столько воды, сколько из него вытекает.

Ваша задача — найти наибольшее количество воды, которое за единицу времени может протекать между источником и стоком, а также скорость течения воды по каждой из труб.

Трубы являются двусторонними, то есть вода в них может течь в любом направлении. Между любой парой узлов может быть более одной трубы.
  
### Входные данные

В первой строке записано натуральное число _N_ — количество узлов в системе (2 ≤ _N_ ≤ 100). Известно, что источник имеет номер 1, а сток номер _N_. Во второй строке записано натуральное _M_ (1 ≤ _M_ ≤ 5000) — количество труб в системе. Далее в _M_ строках идет описание труб. Каждая труба задается тройкой целых чисел _Ai_, _Bi_, _Ci_, где _Ai_, _Bi_ — номера узлов, которые соединяет данная труба (_Ai_ ≠ _Bi_), а _Ci_ (0 ≤ _Ci_ ≤ 104) — наибольшая допустимая скорость течения воды через данную трубу.

### Выходные данные

В первой строке выведите наибольшее количество воды, которое протекает между источником и стоком за единицу времени. Далее выведите _M_ строк, в каждой из которых выведите скорость течения воды по соответствующей трубе. Если направление не совпадает с порядком узлов, заданным во входных данных, то выводите скорость со знаком минус. Числа выводите с точностью 10^(-3).

### Примеры

**входные данные**
```c++
2
2
1 2 1
2 1 3
```
**выходные данные**
```c++
4
1
-3
```

### [Решение](A.cpp)


## B. Разрез
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
  Найдите минимальный разрез между вершинами 1 и _n_ в заданном неориентированном графе.

### Входные данные

На первой строке входного файла содержится _n_ (2 ≤ _n_ ≤ 100) — число вершин в графе и _m_ (0 ≤ _m_ ≤ 400) — количество ребер. На следующих _m_ строках входного файла содержится описание ребер. Ребро описывается номерами вершин, которые оно соединяет, и его пропускной способностью (положительное целое число, не превосходящее 10 000 000), при этом никакие две вершины не соединяются более чем одним ребром.

### Выходные данные

На первой строке выходного файла должны содержаться количество ребер в минимальном разрезе и их суммарная пропускная способность. На следующей строке выведите возрастающую последовательность номеров ребер (ребра нумеруются в том порядке, в каком они были заданы во входном файле).

### Примеры

**входные данные**
```c++
3 3
1 2 3
1 3 5
3 2 7
```
**выходные данные**
```c++
2 8
1 2
```

### [Решение](B.cpp)


## C. Улиточки
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Две улиточки Маша и Петя сейчас находятся в на лужайке с абрикосами и хотят добраться до своего домика. Лужайки пронумерованы числами от 1 до _n_ и соединены дорожками (может быть несколько дорожек соединяющих две лужайки, могут быть дорожки, соединяющие лужайку с собой же). В виду соображений гигиены, если по дорожке проползла улиточка, то вторая по той же дорожке уже ползти не может. Помогите Пете и Маше добраться до домика.

### Входные данные

В первой строке файла записаны четыре целых числа — _n_, _m_, _s_ и _t_ (количество лужаек, количество дорог, номер лужайки с абрикосами и номер домика). В следующих _m_ строках записаны пары чисел. Пара чисел (_x_, _y_) означает, что есть дорожка с лужайки _x_ до лужайки _y_ (из-за особенностей улиток и местности дорожки односторонние). Ограничения: 2 ≤ _n_ ≤ 10^5, 0 ≤ _m_ ≤ 10^5, _s_≠_t_ .

### Выходные данные

Если существует решение, то выведите _YES_ и на двух отдельных строчках сначала последовательность лужаек для Машеньки (дам нужно пропускать вперед), затем путь для Пети. Если решения не существует, выведите _NO_. Если решений несколько, выведите любое.

### Примеры

**входные данные**
```c++
3 3 1 3
1 2
1 3
2 3
```
**выходные данные**
```c++
YES
1 3 
1 2 3 
```

### [Решение](C.cpp)


## D. Паросочетание
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
**Двудольным графом** называется неориентированный граф (_V_, _E_),_E_ ⊆ _V_ × _V_  такой, что его множество вершин _V_ можно разбить на два множества _A_ и _B_, для которых ∀(_e1_, _e2_) ∈ _E_ _e1_ ∈ _A_, _e2_ ∈ _B_ и _A_ ∪ _B_ = _V_,_A_ ⋂	 _B_ = ∅ .

**Паросочетанием** в двудольном графе называется любой набор его несмежных рёбер, то есть такой набор _S_ ⊆ _E_ , что для любых двух рёбер _e1_ = (_u1_, _v1_), _e2_ = (_u2_, _v2_) из _S_ _u1_ ≠ _u2_ и _v1_ ≠ _v2_.

Ваша задача — найти максимальное паросочетание в двудольном графе, то есть паросочетание с максимально возможным числом рёбер.


### Входные данные

В первой строке записаны два целых числа _n_ и _m_ (1 ≤ _n_, _m_ ≤ 250), где _n_ — число вершин в множестве _A_, а _m_ — число вершин в _B_.

Далее следуют _n_ строк с описаниями рёбер — _i_-я вершина из _A_ описана в (_i_ + 1)-й строке файла. Каждая из этих строк содержит номера вершин из _B_, соединённых с _i_-й вершиной _A_. Гарантируется, что в графе нет кратных ребер. Вершины в _A_ и _B_ нумеруются независимо (с единицы). Список завершается числом 0.

### Выходные данные

Первая строка выходного файла должна содержать одно целое число _l_ — количество рёбер в максимальном паросочетании. Далее следуют _l_ строк, в каждой из которых должны быть два целых числа _uj_ и _vj_ — концы рёбер паросочетания в _A_ и _B_ соотвественно.

### Примеры

**входные данные**
```c++
2 2
1 2 0
2 0
```
**выходные данные**
```c++
2
1 1
2 2
```

### [Решение](D.cpp)


## E. Шахматная доска

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Вася любит играть в необычные шахматы. Его братишка Коля был еще очень маленький. Как-то раз, когда Вася вернулся из школы, он увидел, что его любимую шахматную доску кто-то перекрасил. Вася не сильно разозлился на Колю, потому что очень любил своего брата. Так как у них дома были только черная и белая краски, каждая клетка доски была покрашена в один из этих двух цветов.

Вася решил исправить ошибку брата, он решил покрасить доску так, чтобы она снова стала шахматной. Но Вася почему-то подумал, что хочет красить только диагонали. Причем Вася решил не тратить много времени, поэтому его интересует способ покраски, который содержит наименьшее количество действий. За одно действие Вася может покрасить полностью какую-либо диагональ, в любой из двух цветов: черный или белый. Диагонали бывают двух типов, в зависимости от направления прямой, на которой лежит диагональ. Диагональ, которая лежит на прямой, направленной влево и вниз, является диагональю первого типа, а диагональ, которая лежит на прямой, направленной вправо и вниз, — второго.

Вам предстоит помочь Васе. Задано испорченное Колей шахматное поле. Вам необходимо определить, за какое минимальное количество действий Вася сможет перекрасить доску так, чтобы она стала шахматной.

### Входные данные

В первой строке входного файла записаны два целых числа: _n_ и _m_ (1 ≤ _n_, _m_ ≤ 100) — количество строчек и количество столбцов шахматного поля соответственно.

В следующих _n_ строках записано поле, в каждой строке по _m_ символов. Каждая строка входного файла описывает одну строку шахматного поля. _W_ соответствует белой клетке, _B_ — черной.

### Выходные данные

В выходной файл нужно вывести число _p_, количество действий, которое потребуется Васе, чтобы его доска снова стала шахматной. В следующих _p_ строках описаны действия. Каждое действие описано тремя параметрами: тип диагонали, координаты клетки и цвет. Тип диагонали — это число 1 или 2. Координаты клетки — это два целых числа: строка и столбец одной из клеток, которую покрасили этим действием. Цвет — это символ _W_ или _B_, белый и черный соответственно.

### Примеры

**входные данные**
```c++
3 3
WBB
BWB
BBW
```
**выходные данные**
```c++
1
1 1 3 W
```

**входные данные**
```c++
3 3
WBW
WWB
WWW
```
**выходные данные**
```c++
1
2 2 1 B
```

**входные данные**
```c++
1 3
WWW
```
**выходные данные**
```c++
1
1 1 2 B
```

### [Решение](E.cpp)



## F. Двигаем предметы

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
На плоскости расположены n предметов, их нужно переместить в заданные n позиций. При этом не важно, какой предмет какую из них займет. Для каждого предмета известна максимальная скорость, с которой его можно перемещать, при этом перемещать все предметы можно одновременно.

Найдите минимальное время, за которое можно переместить предметы на заданные места.

### Входные данные

В первой строке записано число _n_ (1 ≤ _n_ ≤ 50), в следующих _n_ строках содержатся описания предметов, в _i_-ой из которых, находится три числа координаты _xi_, _yi_ (1 ≤ _xi_, _yi_ ≤ 1000) и максимальная скорость _vi_ (1 ≤ _vi_ ≤ 10) _i_-ого предмета соответственно. В следующих _n_ строках содержатся описания финальных позиций, в _i_-ой из которых, заданы координаты _ai_, _bi_ (1 ≤ _ai_, _bi_ ≤ 1000) _i_-ой финальной позиции.

### Выходные данные

Выведите одно число — минимальное время, за которое можно переместить предметы. Погрешность не более 10^(-4).

### Примеры

**входные данные**
```c++
2
0 0 1
0 1 1
1 1
1 0
```
**выходные данные**
```c++
1.0
```

**входные данные**
```c++
2
0 0 1
0 1 1
1 1
2 1
```
**выходные данные**
```c++
2.0
```

**входные данные**
```c++
2
0 0 1
5 0 1
5 12
10 12
```
**выходные данные**
```c++
12.0
```

**входные данные**
```c++
4
78 520 5
827 239 5
620 200 7
809 269 7
986 496
754 745
772 375
44 223
```
**выходные данные**
```c++
68.45242650102003
```

### [Решение](F.cpp)


## G. Великая стена

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
У короля Людовика двое сыновей. Они ненавидят друг друга, и король боится, что после его смерти страна будет уничтожена страшными войнами. Поэтому Людовик решил разделить свою страну на две части, в каждой из которых будет властвовать один из его сыновей. Он посадил их на трон в города _A_ и _B_, и хочет построить минимально возможное количество фрагментов стены таким образом, чтобы не существовало пути из города _A_ в город _B_.

Страну, в которой властвует Людовик, можно упрощенно представить в виде прямоугольника _m_ × _n_. В некоторых клетках этого прямоугольника расположены горы, по остальным же можно свободно перемещаться. Кроме этого, ландшафт в некоторых клетках удобен для строительства стены, в остальных же строительство невозможно.

При поездках по стране можно перемещаться из клетки в соседнюю по стороне, только если ни одна из этих клеток не содержит горы или построенного фрагмента стены.

### Входные данные

В первой строке входного файла содержатся числа _m_ и _n_ (1 ≤ _m_, _n_ ≤ 50). Следующие _m_ строк по _n_ символов задают карту страны. Символы обозначают: «#» — гора, «.» — место, пригодное для постройки стены, «-» — место, не пригодное для постройки стены, «A» и «B» — города A и _B_.

### Выходные данные

В первой строке выходного файла должно быть выведено минимальное количество фрагментов стены _F_, которые необходимо построить. Далее нужно вывести карту в том же формате, как во входном файле. Клетки со стеной обозначьте символом «+».

Если невозможно произвести требуемую застройку, то выведите в выходной файл единственное число  -1.

### Примеры

**входные данные**
```c++
5 5
--...
A-.#-
.#.#-
--.--
--.-B
```
**выходные данные**
```c++
3
--+..
A-+#-
+#.#-
--.--
--.-B
```

**входные данные**
```c++
1 2
AB
```
**выходные данные**
```c++
-1
```

**входные данные**
```c++
2 2
A#
#B
```
**выходные данные**
```c++
0
A#
#B
```

### [Решение](G.cpp)


## H. Космические перевозки

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  **ввод: bring.in**
  
  **вывод: bring.out**
  
К 3141 году человеческая цивилизация распространилась по всей галактике. Для перехода от одной звездной системы к другой используются специальные гипертуннели. Чтобы использовать гипертуннель, нужно прилететь в специальное место рядом с исходной звездой используя ваш космический корабль, активировать гипердрайв, пролететь через гипертуннель, выйти рядом со звездой назначения и лететь на нужную вам планету. Весь процесс занимает ровно один день. Небольшой недостаток системы состоит в том, что по каждому туннелю может пролететь только один космический корабль в день.

Вы работаете в транспортном отделе компании «Intergalaxy Business Machines». Сегодня утром ваш начальник дал вам новую задачу. Чтобы запустить чемпионат по программированию IBM, нужно доставить _K_ суперкомпьютеров от Земли, где находится штаб-квартира компании на планету Эйсиэм.

Поскольку суперкомпьютеры очень большие, нужно, для перевозки одного нужен целый космический корабль. Вас попросили найти план доставки суперкомпьютеров, который позволит доставить все компьютеры за минимальное число дней. Поскольку IBM является очень мощной корпорацией, можете считать, что каждый раз, когда вам нужен какой-то гипертуннель, он к вашим услугам. Однако вы все равно можно использовать каждый туннель только один раз в день.

### Входные данные

Первая строка входного файла содержит _N_ — число звездных систем в галактике, _M_ — число туннелей, _K_ — число суперкомпьютеров для доставки, _S_ — номер солнечной системы, где находится планета Земля и _T_ — номер звездной системы, где находится Планета Эйсиэм ({2 ≤ _N_ ≤ 50}, {1 ≤ _M_ ≤ 200}, {1 ≤ _K_ ≤ 50}, {1 ≤ _S_, _T_ ≤ _N_}, {_S_ ≠ _T_})

Следующие _M_ строк содержат по два разных целых числа и описывают туннели. Для каждого туннеля даются номера звездных систем, которые он соединяет. По туннелю можно путешествовать в обоих направлениях, но помните, что каждый день только один корабль может использовать туннель. В частности, два судна не могут одновременно проходить через один и тот же туннель в противоположных направлениях. Ни один туннель не соединяет звезду с самим собой и две звезды связаны не более чем одним туннелем.

### Выходные данные

В первой строке выходного файла выведите _L_ — наименьшее число дней, необходимых для доставки _K_ суперкомпьютеров от звездной системы _S_ до звездной системы _T_ с использованием гипертуннелей.

Следующие _L_ строк должны описывать процесс. Каждая строка должна начинаться с _Ci_ — числа кораблей, которые отправляются из одной системы в другую в этот день. Далее должны следовать _Ci_ пар целых чисел, пара _A_, _B_ означает, что корабль номер _A_ перемещается из текущей звездной системы в звездную систему _B_.

### Примеры

**входные данные**
```c++
6 7 4 1 6
1 2
2 3
3 5
5 6
1 4
4 6
4 3
```
**выходные данные**
```c++
4
2  3 2  4 4
3  2 4  3 3  4 6
3  1 4  2 6  3 5
2  1 6  3 6
```

### [Решение](H.cpp)



## I. Групповой турнир

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
В нашем капиталистическом и меркантильном мире всё решают деньги, и даже спорт не стал исключением. Все команды-участницы уже купили себе нужное количество очков в следующем сезоне, и местной федерации хоккея осталось только распределить результаты предстоящих игр. Однако, некоторые команды не поскупились и помимо покупки очков также купили ещё и результаты некоторых игр. Поначалу в федерации думали, что это им только упростит задачу: чем для большего числа игр результаты уже определены, тем меньше работы остаётся им. Но позже они поняли, что ошиблись. Они попросили вас стать участником их коррупционной схемы и помочь с распределением результатов игр предстоящего сезона.

Местный хоккейный турнир проходит по круговой системе: в турнире участвуют _N_ команд и каждая команда играет с каждой ровно одно игру. За игру команды получают очки по следующим правилам:

Если победителя удалось выявить в основное время матча, то ему достаётся 3 очка, а проигравшему — 0.
Если основное время закончилось вничью и для выявления победителя понадобилось дополнительное время (овертайм), то победителю дают 2 очка, а проигравшему — 1 очко. Овертайм не ограничен во времени и длится до тех пор, пока одна из команд не забьёт гол.
По итогам турнира очки команды определяются как сумма её очков по всем сыгранным играм.

### Входные данные

В первой строке входного файла содержится целое число _N_ — количество участников турнира (2  ≤  _N_  ≤  100). Команды занумерованы числами от 1 до _N_.

Следующие _N_ строк файла содержат по _N_ символов и представляют собой турнирную таблицу на данный момент. Символ _aij_ в строке i (1  ≤  _i_  ≤  _N_) на позиции j (1  ≤  _j_  ≤  _N_) означает результат игры команды номер _i_ с командой номер _j_ и может быть одним из:

'_W_' — означает, что команда _i_ обыграет команду _j_ в основное время матча;
'_w_' — команда _i_ обыграет команду _j_ в овертайме;
'_l_' — команда _i_ проиграет команде _j_ в овертайме;
'_L_' — команда _i_ проиграет команде _j_ в основное время матча;
'.' — если результат игры между командами _i_ и _j_ ещё не определён;
'#' — если _i_ равно _j_, означает отсутствие данного матча, т. к. команда не может играть сама с собой.
Гарантируется, что данная таблица корректна. Более формально:

_aij_ = '#' для всех _i_ = _j_;
если _aij_ = '.', то _aji_ = '.';
_aij_ = '_W_' тогда и только тогда, когда _aji_ = '_L_';
_aij_ = '_w_' тогда и только тогда, когда _aji_ = '_l_'.
Последняя строка входного файла содержит _N_ целых чисел _pi_ — количество очков, которое требуется набрать _i_-й команде (1  ≤  _i_  ≤  _N_).

### Выходные данные

В выходной файл выведите полностью заполненную турнирную таблицу в формате, аналогичном формату входного файла.

Гарантируется, что решение существует. Если решений несколько, то можно вывести любое из них.

### Примеры

**входные данные**
```c++
4
#..W
.#w.
.l#.
L..#
8 6 3 1
```
**выходные данные**
```c++
#wWW
l#wW
Ll#w
LLl#
```

### [Решение](I.cpp)


## J. Тараканы

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Несколько чистоплотных тараканьих семей хотят поселиться в однокомнатной квартире. Квартира состоит из большой комнаты и кухни, соединѐнных узким коридором. Тараканов совершенно не интересует коридор сам по себе, однако они хотят иметь доступ и к кухне, и к комнате. Для того чтобы тараканья семья имела такой доступ, ей нужен индивидуальный транспортный путь через коридор. Тараканы — умные насекомые, поэтому они решили составить план коридора и определить, какое максимальное количество транспортных путей можно проложить через коридор.

В тараканьем плане коридор представляется бесконечной в обе стороны полосой шириной _W_ сантиметров. Тараканы начертили прямоугольную систему координат, ось _X_ которой параллельна направлению коридора. Хозяева квартиры расставили в коридоре некоторое количество массивных предметов. Каждый предмет является прямоугольником со сторонами, параллельными осям координат, и вершинами с целыми координатами в сантиметрах. Границы коридора задаются уравнениями _y_ = 0 и _y_ = _W_. На координатной плоскости тараканы нарисовали квадратную сетку со стороной одной клетки, равной 1 см, начиная от границы коридора.

Тараканы договорились, что каждый транспортный путь является бесконечной в обе стороны цепью квадратных клеток. Цивилизованные тараканы никогда не прыгают, поэтому две подряд идущие клетки в этой цепи должны быть соседними по стороне. Цивилизованные тараканы всегда бегают по полу, поэтому никакая клетка цепи не может пересекаться с хозяйской вещью или выходить за пределы коридора. Тараканы не любят бегать по кругу, поэтому все клетки цепи различны. Тараканы не хотят давки в час пик, поэтому они требуют, чтобы различные транспортные пути не пересекались, то есть не имели общих клеток. Транспортный путь должен соединять кухню и комнату, поэтому разные концы цепи должны уходить в разные стороны коридора.

Ваша задача — определить максимальное количество транспортных путей, которые можно проложить через коридор.

### Входные данные

В первой строке входного файла записано два целых числа _N_ и _W_. _N_ — количество предметов в коридоре, _W_ — ширина коридора в сантиметрах (0 ≤ _N_ ≤ 5000, 0 < _W_ ≤ 10^9).

Каждая из последующих _N_ строк описывает одну из хозяйских вещей. Она содержит четыре целых числа _X1_, _Y1_, _X2_, _Y2_ — координаты двух противоположных углов прямоугольника ( -10^9 ≤ _X1_ < _X2_ ≤ 10^9, 0 ≤ _Y1_ < _Y2_ ≤ _W_). Предметы, расставленные в коридоре, могут пересекаться.-

### Выходные данные

В выходной файл нужно вывести одно целое число — максимально возможное количество транспортных путей.

### Примеры

**входные данные**
```c++
2 9
-4 4 -1 7
2 1 5 5
```
**выходные данные**
```c++
5
```

### [Решение](J.cpp)
