# Потоки и паросочетания

## A. Просто поток
  ограничение по времени на тест: 5 секунд
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
 Дана система из узлов и труб, по которым может течь вода. Для каждой трубы известна наибольшая скорость, с которой вода может протекать через нее. Известно, что вода течет по трубам таким образом, что за единицу времени в каждый узел (за исключением двух — источника и стока) втекает ровно столько воды, сколько из него вытекает.

Ваша задача — найти наибольшее количество воды, которое за единицу времени может протекать между источником и стоком, а также скорость течения воды по каждой из труб.

Трубы являются двусторонними, то есть вода в них может течь в любом направлении. Между любой парой узлов может быть более одной трубы.
  
### Входные данные

В первой строке записано натуральное число _N_ — количество узлов в системе (2 ≤ _N_ ≤ 100). Известно, что источник имеет номер 1, а сток номер _N_. Во второй строке записано натуральное _M_ (1 ≤ _M_ ≤ 5000) — количество труб в системе. Далее в _M_ строках идет описание труб. Каждая труба задается тройкой целых чисел _Ai_, _Bi_, _Ci_, где _Ai_, _Bi_ — номера узлов, которые соединяет данная труба (_Ai_ ≠ _Bi_), а _Ci_ (0 ≤ _Ci_ ≤ 104) — наибольшая допустимая скорость течения воды через данную трубу.

### Выходные данные

В первой строке выведите наибольшее количество воды, которое протекает между источником и стоком за единицу времени. Далее выведите _M_ строк, в каждой из которых выведите скорость течения воды по соответствующей трубе. Если направление не совпадает с порядком узлов, заданным во входных данных, то выводите скорость со знаком минус. Числа выводите с точностью 10^(-3).

### Примеры

**входные данные**
```c++
2
2
1 2 1
2 1 3
```
**выходные данные**
```c++
4
1
-3
```

### [Решение](A.cpp)


## B. Разрез
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
  Найдите минимальный разрез между вершинами 1 и _n_ в заданном неориентированном графе.

### Входные данные

На первой строке входного файла содержится _n_ (2 ≤ _n_ ≤ 100) — число вершин в графе и _m_ (0 ≤ _m_ ≤ 400) — количество ребер. На следующих _m_ строках входного файла содержится описание ребер. Ребро описывается номерами вершин, которые оно соединяет, и его пропускной способностью (положительное целое число, не превосходящее 10 000 000), при этом никакие две вершины не соединяются более чем одним ребром.

### Выходные данные

На первой строке выходного файла должны содержаться количество ребер в минимальном разрезе и их суммарная пропускная способность. На следующей строке выведите возрастающую последовательность номеров ребер (ребра нумеруются в том порядке, в каком они были заданы во входном файле).

### Примеры

**входные данные**
```c++
3 3
1 2 3
1 3 5
3 2 7
```
**выходные данные**
```c++
2 8
1 2
```

### [Решение](B.cpp)


## C. Улиточки
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Две улиточки Маша и Петя сейчас находятся в на лужайке с абрикосами и хотят добраться до своего домика. Лужайки пронумерованы числами от 1 до _n_ и соединены дорожками (может быть несколько дорожек соединяющих две лужайки, могут быть дорожки, соединяющие лужайку с собой же). В виду соображений гигиены, если по дорожке проползла улиточка, то вторая по той же дорожке уже ползти не может. Помогите Пете и Маше добраться до домика.

### Входные данные

В первой строке файла записаны четыре целых числа — _n_, _m_, _s_ и _t_ (количество лужаек, количество дорог, номер лужайки с абрикосами и номер домика). В следующих _m_ строках записаны пары чисел. Пара чисел (_x_, _y_) означает, что есть дорожка с лужайки _x_ до лужайки _y_ (из-за особенностей улиток и местности дорожки односторонние). Ограничения: 2 ≤ _n_ ≤ 10^5, 0 ≤ _m_ ≤ 10^5, _s_≠_t_ .

### Выходные данные

Если существует решение, то выведите _YES_ и на двух отдельных строчках сначала последовательность лужаек для Машеньки (дам нужно пропускать вперед), затем путь для Пети. Если решения не существует, выведите _NO_. Если решений несколько, выведите любое.

### Примеры

**входные данные**
```c++
3 3 1 3
1 2
1 3
2 3
```
**выходные данные**
```c++
YES
1 3 
1 2 3 
```

### [Решение](C.cpp)


## D. Паросочетание
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
**Двудольным графом** называется неориентированный граф (_V_, _E_),_E_ ⊆ _V_ × _V_  такой, что его множество вершин _V_ можно разбить на два множества _A_ и _B_, для которых ∀(_e1_, _e2_) ∈ _E_ _e1_ ∈ _A_, _e2_ ∈ _B_ и _A_ ∪ _B_ = _V_,_A_ ⋂	 _B_ = ∅ .

**Паросочетанием** в двудольном графе называется любой набор его несмежных рёбер, то есть такой набор _S_ ⊆ _E_ , что для любых двух рёбер _e1_ = (_u1_, _v1_), _e2_ = (_u2_, _v2_) из _S_ _u1_ ≠ _u2_ и _v1_ ≠ _v2_.

Ваша задача — найти максимальное паросочетание в двудольном графе, то есть паросочетание с максимально возможным числом рёбер.


### Входные данные

В первой строке записаны два целых числа _n_ и _m_ (1 ≤ _n_, _m_ ≤ 250), где _n_ — число вершин в множестве _A_, а _m_ — число вершин в _B_.

Далее следуют _n_ строк с описаниями рёбер — _i_-я вершина из _A_ описана в (_i_ + 1)-й строке файла. Каждая из этих строк содержит номера вершин из _B_, соединённых с _i_-й вершиной _A_. Гарантируется, что в графе нет кратных ребер. Вершины в _A_ и _B_ нумеруются независимо (с единицы). Список завершается числом 0.

### Выходные данные

Первая строка выходного файла должна содержать одно целое число _l_ — количество рёбер в максимальном паросочетании. Далее следуют _l_ строк, в каждой из которых должны быть два целых числа _uj_ и _vj_ — концы рёбер паросочетания в _A_ и _B_ соотвественно.

### Примеры

**входные данные**
```c++
2 2
1 2 0
2 0
```
**выходные данные**
```c++
2
1 1
2 2
```

### [Решение](D.cpp)


