# Потоки и паросочетания

## A. Сравнения подстрок

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
  Дана строка. Нужно уметь отвечать на запросы вида: равны ли подстроки [a..b] и [c..d].  

### Входные данные

Сперва строка _S_ (не более 10^5 строчных латинских букв). Далее число _M_ — количество запросов.

В следующих _M_ строках запросы _a_,_b_,_c_,_d_. 0 ≤ _M_ ≤ 10^5, 1 ≤ _a_ ≤ _b_ ≤ |_S_|, 1 ≤ _c_ ≤ _d_ ≤ |_S_|

### Выходные данные

_M_ строк. Выведите Yes, если подстроки совпадают, и No иначе.

### Примеры

**входные данные**
```c++
trololo
3
1 7 1 7
3 5 5 7
1 1 1 5
```
**выходные данные**
```c++
Yes
Yes
No
```

### [Решение](A.cpp)


## B. Префикс-функция

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Постройте префикс-функцию для заданной строки _s_.

### Входные данные

Первая строка входного файла содержит _s_ (1 ≤ |_s_| ≤ 10^6). Строка состоит из букв латинского алфавита.

### Выходные данные

Выведите значения префикс-функции строки _s_ для всех индексов 1, 2, ..., |_s_|.

### Примеры

**входные данные**
```c++
aaaAAA
```
**выходные данные**
```c++
0 1 2 0 0 0
```

### [Решение](B.cpp)


## C. Z-функция

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Постройте Z-функцию для заданной строки _s_.

### Входные данные

Первая строка входного файла содержит _s_ (1 ≤ |_s_| ≤ 10^6). Строка состоит из букв латинского алфавита.

### Выходные данные

Выведите значения Z-функции строки _s_ для индексов 2, 3, ..., |_s_|.

### Примеры

**входные данные**
```c++
aaaAAA
```
**выходные данные**
```c++
 2 1 0 0 0
 ```
 
 **входные данные**
```c++
abacaba
```
**выходные данные**
```c++
 0 1 0 3 0 1
 ```

### [Решение](C.cpp)


## D. Быстрый поиск подстроки в строке

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Даны строки _p_ и _t_. Требуется найти все вхождения строки _p_ в строку _t_ в качестве подстроки.

### Входные данные

Первая строка входного файла содержит _p_, вторая — _t_ (1 ≤ |_p_|, |_t_| ≤ 10^6). Строки состоят из букв латинского алфавита.

### Выходные данные

В первой строке выведите количество вхождений строки _p_ в строку _t_. Во второй строке выведите в возрастающем порядке номера символов строки _t_, с которых начинаются вхождения _p_. Символы нумеруются с единицы.

### Примеры

**входные данные**
```c++
aba
abaCaba
```
**выходные данные**
```c++
2
1 5
 ```

### [Решение](D.cpp)


## E. Поиск периода

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дана строка _s_. Требуется найти минимальную по длине строку _t_, такую что _s_ представима в виде конкатенации одной или нескольких строк _t_.

### Входные данные

Первая строка входного файла содержит _s_ (1 ≤ |_s_| ≤ 10^6). Строка состоит из букв латинского алфавита.

### Выходные данные

Выведите длину искомой строки _t_.

### Примеры

**входные данные**
```c++
abacaba
```
**выходные данные**
```c++
7
 ```
 
 **входные данные**
```c++
abcabcabc
```
**выходные данные**
```c++
3
 ```

### [Решение](E.cpp)


## F. Подстроки-3

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Даны _K_ строк из маленьких латинских букв. Требуется найти их наибольшую общую подстроку.

### Входные данные

В первой строке число _K_ (1 ≤ _K_ ≤ 10).

В следующих _K_ строках — собственно _K_ строк (длины строк от 1 до 10 000).

### Выходные данные

Наибольшая общая подстрока.

### Примеры

**входные данные**
```c++
3
abacaba
mycabarchive
acabistrue
```
**выходные данные**
```c++
cab
 ```
 
 
 ## G. Множественный поиск

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  **ввод: search4.in**
  
  **вывод: search4.out**
  
Дан массив строк _si_ и строка _t_. Требуется для каждой строки _si_ определить, встречается ли она в _t_ как подстрока.

### Входные данные

Первая строка входного файла содержит целое число _n_ — число элементов в _s_ (1 ≤ _n_ ≤ 10^6). Следующие _n_ строк содержат по одной строке _si_. Сумма длин всех строк из _s_ не превосходит 10^6. Последняя строка входного файла содержит _t_ (1 ≤ _t_ ≤ 10^6). Все строки состоят из строчных латинских букв.

### Выходные данные

Для каждой строки _si_ выведите «YES», если она встречается в _t_ и «NO» в противном случае. Строки нумеруются в порядке появления во входном файле.

### Примеры

**входные данные**
```c++
3
abc
abcdr
abcde
xabcdef
```
**выходные данные**
```c++
YES
NO
YES
 ```
 
### [Решение](G.cpp)


 ## H. Множественный поиск 2

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  **ввод: search5.in**
  
  **вывод: search5.out**
  
Дан массив строк _si_ и строка _t_. Требуется для каждой строки _si_ определить, сколько раз она встречается в _t_ как подстрока.

### Входные данные

Первая строка входного файла содержит целое число _n_ — число элементов в _s_ (1 ≤ _n_ ≤ 10^6). Следующие _n_ строк содержат по одной строке _si_. Сумма длин всех строк из _s_ не превосходит 10^6. Последняя строка входного файла содержит _t_ (1 ≤ _t_ ≤ 10^6). Все строки состоят из строчных латинских букв

### Выходные данные

Для каждой строки _si_ выведите одно число: сколько раз она встречается в _t_. Строки нумеруются в порядке появления во входном файле.

### Примеры

**входные данные**
```c++
3
abc
abcdr
abcde
xabcdef
```
**выходные данные**
```c++
1
0
1
 ```
 
 
  ## I. Множественный поиск 3

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 512 мегабайт
  
  **ввод: search6.in**
  
  **вывод: search6.out**
  
Дан массив строк _si_ и строка _t_. Требуется для каждой строки _si_ найти самое левое и самое правое вхождение в _t_ как подстроки.

### Входные данные

Первая строка входного файла содержит целое число _n_ — число элементов в _s_ (1 ≤ _n_ ≤ 10^6). Следующие _n_ строк содержат по одной строке _si_. Сумма длин всех строк из _s_ не превосходит 10^6. Последняя строка входного файла содержит _t_ (1 ≤ _t_ ≤ 10^6). Все строки состоят из строчных латинских букв.

### Выходные данные

Для каждой строки _si_ выведите два числа: индексы самой левой и самой правой позиции, в которых она встречается в _t_. Если строка не встречается в _t_ ни разу, выведите  - 1  - 1. Строки нумеруются в порядке появления во входном файле. Позиции нумеруются с 0.

### Примеры

**входные данные**
```c++
3
ab
bcd
abde
abcdab
```
**выходные данные**
```c++
0 4
1 1
-1 -1
 ```
 
 
  ## J. Суффиксный массив

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 512 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Постройте суффиксный массив для заданной строки _s_, для каждых двух соседних суффиксов найдите длину максимального общего префикса.

### Входные данные

Первая строка входного файла содержит строку _s_ (1 ≤ |_s_| ≤ 400 000). Строка состоит из строчных латинских букв.

### Выходные данные

В первой строке выведите |_s_| различных чисел — номера первых символов суффиксов строки _s_ так, чтобы соответствующие суффиксы были упорядочены в лексикографически возрастающем порядке. Во второй строке выведите |_s_| - 1 чисел — длины наибольших общих префиксов.

### Примеры

**входные данные**
```c++
ababb
```
**выходные данные**
```c++
1 3 5 2 4 
2 0 1 1 
 ```
 
### [Решение](J.cpp)


  ## K. Количество подстрок
  
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 512 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Вычислите количество различных подстрок строки _s_.

### Входные данные

Единственная строка входного файла содержит строку _s_ (1 ≤ |_s_| ≤ 400 000). Строка состоит из строчных латинских букв.

### Выходные данные

Выведите одно число — ответ на задачу.

### Примеры

**входные данные**
```c++
ababb
```
**выходные данные**
```c++
11
 ```
 
### [Решение](K.cpp)


## L. Циклические сдвиги
  
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 512 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
_k-м циклическим сдвигом_ строки _S_ называется строка, полученная перестановкой _k_ первых символов строки _S_ в конец строки.

Рассмотрим все различные циклические сдвиги строки _S_ и отсортируем их по возрастанию. Требуется вычислить _i_-ю строчку этого массива.

Например, для строки abacabac существует четыре различных циклических сдвига: нулевой (abacabac), первый (bacabaca), второй (acabacab) и третий (cabacaba). После сортировки по возрастанию получится такой массив: abacabac, acabacab, bacabaca, cabacaba.

### Входные данные

В первой строке входного файла записана строка _S_, длиной не более 100 000 символов с ASCII-кодами от 32 до 126. Во второй строке содержится единственное целое число _k_ (1 ≤ _k_ ≤ 100 000).

### Выходные данные

В выходной файл выведите _k_-й по возрастанию циклический сдвиг строки _S_, или слово IMPOSSIBLE, если такого сдвига не существует.

### Примеры

**входные данные**
```c++
abacabac
4
```
**выходные данные**
```c++
cabacaba
 ```
 
 **входные данные**
```c++
abacabac
5
```
**выходные данные**
```c++
IMPOSSIBLE
 ```
 
### [Решение](L.cpp)


## M. Наибольшая общая подстрока
  
  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 512 мегабайт
  
  **ввод: common.in**
  
  **вывод: common.out**
  
Найдите наибольшую общую подстроку строк _s_ и _t_.

### Входные данные

Первая строка входного файла содержит строку _s_, вторая — _t_ (1 ≤ |_s_|, |_t_| ≤ 100, 000). Строки состоят из строчных латинских букв.

### Выходные данные

Выведите одну строку — наибольшую общую подстроку строк _s_ и _t_. В случае, если ответ не единственный, выведите минимальный лексикографически.

### Примеры

**входные данные**
```c++
bababb
zabacabba
```
**выходные данные**
```c++
cabacaba
 ```
 
 **входные данные**
```c++
abacabac
5
```
**выходные данные**
```c++
aba
 ```
 
### [Решение](M.cpp)
