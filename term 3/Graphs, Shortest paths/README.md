# Графы, кратчайшие пути

## A. Флойд

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Полный ориентированный взвешенный граф задан матрицей смежности. Постройте матрицу кратчайших путей между его вершинами. Гарантируется, что в графе нет циклов отрицательного веса.

### Входные данные

В первой строке вводится единственное число _N_ (1 ≤ _N_ ≤ 100) — количество вершин графа. В следующих _N_ строках по _N_ чисел задается матрица смежности графа (_j_-ое число в _i_-ой строке — вес ребра из вершины _i_ в вершину _j_). Все числа по модулю не превышают 100. На главной диагонали матрицы — всегда нули.

### Выходные данные

Выведите _N_ строк по _N_ чисел — матрицу расстояний между парами вершин, где _j_-ое число в _i_-ой строке равно весу кратчайшего пути из вершины _i_ в _j_.

### Примеры

**входные данные**
```c++
4
0 5 9 100
100 0 2 8
100 100 0 7
4 100 100 0
```
**выходные данные**
```c++
0 5 7 13 
12 0 2 8 
11 16 0 7 
4 9 11 0 
```

### [Решение](A.cpp)


## B. Кратчайший путь-2

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дан неориентированный связный взвешенный граф. Найдите кратчайшее расстояние от первой вершины до всех вершин.

### Входные данные

В первой строке входного файла два числа: _n_ и _m_ (2 ≤ _n_ ≤ 30000, 1 ≤ _m_ ≤ 400000), где _n_ — количество вершин графа, а _m_ — количество ребер.

Следующие _m_ строк содержат описание ребер. Каждое ребро задается стартовой вершиной, конечной вершиной и весом ребра. Вес каждого ребра — неотрицательное целое число, не превосходящее 10^4.

### Выходные данные

Выведите _n_ чисел — для каждой вершины кратчашее расстояние до нее.

### Примеры

**входные данные**
```c++
4 5
1 2 1
1 3 5
2 4 8
3 4 1
2 3 3
```
**выходные данные**
```c++
0 1 4 5
```

### [Решение](B.cpp)


## C. Цикл отрицательного веса

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дан ориентированный граф. Определите, есть ли в нем цикл отрицательного веса, и если да, то выведите его.

### Входные данные

Во входном файле в первой строке число _N_ (1 ≤ _N_ ≤ 100) — количество вершин графа. В следующих _N_ строках находится по _N_ чисел — матрица смежности графа. Все веса ребер не превышают по модулю 10 000. Если ребра нет, то соответствующее число равно 100 000.

### Выходные данные

В первой строке выходного файла выведите «YES», если цикл существует или «NO» в противном случае. При его наличии выведите во второй строке количество вершин в искомом цикле и в третьей строке — вершины входящие в этот цикл в порядке обхода.

### Примеры

**входные данные**
```c++
2
0 -1
-1 0
```
**выходные данные**
```c++
YES
2
2 1 
```

### [Решение](C.cpp)


## D. Кратчайший путь длины _K_

  ограничение по времени на тест: 4 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Дан ориентированный граф. Найдите кратчайшие пути, состоящие из _K_ рёбер, от _S_ до всех вершин.

### Входные данные

В первой строке дано целых четыре целых числа: 1 ≤ _N_, _M_ ≤ 10^4 — количества вершин и рёбер, 0 ≤ _K_ ≤ 100 — количество рёбер в кратчайших путях, 1 ≤ _S_ ≤ _N_ — начальная вершина.

В последующих _M_ строках даны тройки целых чисел _ai_, _bi_, _w_ — начало и конец ребра, а также его вес (1 ≤ _ai_, _bi_ ≤ _N_,  - 10^5 ≤ _w_ ≤ 10^5).

### Выходные данные

Выведите ровно _N_ чисел по одному в строке. _i_-е число — длина минимального пути из ровно _K_ рёбер из _S_ в _i_, или  - 1, если пути не существует.

### Примеры

**входные данные**
```c++
3 3 1 1
1 2 100
2 3 300
1 3 2
```
**выходные данные**
```c++
-1
100
2
```

**входные данные**
```c++
3 3 2 1
1 2 100
2 3 300
1 3 2
```
**выходные данные**
```c++
-1
-1
400
```

### [Решение](D.cpp)


## E. Кратчайшие пути

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Вам дан взвешенный ориентированный граф и вершина _s_ в нём. Для каждой вершины графа _u_ выведите длину кратчайшего пути от вершины _s_ до вершины _u_.

### Входные данные

Первая строка входного файла содержит три целых числа _n_, _m_, _s_ — количество вершин и ребёр в графе и номер начальной вершины соответственно (2 ≤ _n_ ≤ 2 000, 1 ≤ _m_ ≤ 5 000).

Следующие _m_ строчек описывают рёбра графа. Каждое ребро задаётся тремя числами — начальной вершиной, конечной вершиной и весом ребра соответственно. Вес ребра — целое число, не превосходящее 10^15 по абсолютной величине. В графе могут быть кратные рёбра и петли.

### Выходные данные

Выведите _n_ строчек — для каждой вершины _u_ выведите длину кратчайшего пути из _s_ в _u_. Если не существует пути между _s_ и _u_, выведите «*». Если не существует кратчайшего пути между _s_ и _u_, выведите «-».

### Примеры

**входные данные**
```c++
6 7 1
1 2 10
2 3 5
1 3 100
3 5 7
5 4 10
4 3 -18
6 1 -1
```
**выходные данные**
```c++
0
10
-
-
-
*
```

### [Решение](E.cpp)


## F. В поисках утраченного кефира

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Школьник Вася хочет найти запасы спрятанного кефира. По легенде, кефир находится в домиках _a_, _b_ или _c_. Вася хочет проверить каждый из этих трёх домиков, потратив на это минимальное количество времени.

Местность, в которой находится Вася представляет собой n домиков, пронумерованных числами от 1 до _n_. Некоторые из домиков соединены дорогами, по которым можно ходить в обе стороны. Время прохождения _i_-й дороги составляет _wi_ секунд. Путём в графе называется непустая последовательность вершин, такая что все соседние вершины соединены дорогой. Требуется помочь Васе найти путь, содержащий вершины _a_, _b_, _c_, такой что суммарное время прохождения всех дорог на пути минимально. При этом, если мы прошли по какой-то дороге дважды (или более), то и время её прохождения следует учитывать соответствующее количество раз. Начинать свой путь Вася может из любой вершины.

Гарантируется, что _a_, _b_, _c_ — попарно различные домики.

### Входные данные

В первой строке ввода записаны два числа _n_ и _m_ (3 ≤ _n_ ≤ 100 000, 0 ≤ _m_ ≤ 200 000) — количество домиков в ЛКШ и дорог между ними соответственно.

Следующие _m_ строк содержат описания дорог, по одному в строке. Каждая из дорог задаётся тройкой чисел _ui_, _vi_, _wi_ (1 ≤ _ui_, _vi_ ≤ _n_, 1 ≤ _wi_ ≤ 10^9) — номерами соединённых домиков и временем, затрачиваемым на прохождение данной дороги. По каждой дороге разрешено ходить в обе стороны. Гарантируется, что любая пара домиков соединена не болee чем одной дорогой. Также гарантируется, что нет дороги, соединяющей домик с самим собой.

В последней строке записаны три попарно различных числа _a_, _b_, _c_ (1 ≤ _a_, _b_, _c_ ≤ _n_).

### Выходные данные

Выведите одно целое число — минимальное возможное время, которое нужно затратить на прохождение пути, содержащего домики _a_, _b_ и _c_. Если пути, содержащего все три домика не существует, то выведите -1.

### Примеры

**входные данные**
```c++
4 4
1 2 3
2 3 1
3 4 7
4 2 10
1 4 3
```
**выходные данные**
```c++
11
```

**входные данные**
```c++
4 2
1 2 10
2 3 5
1 2 4
```
**выходные данные**
```c++
-1
```

### Примечание
В первом примере путь 1–2–3–4 является минимальным (11 секунд). Например, путь 1–2–4–3 не подходит, так как занимает больше времени (20 секунд), а путь 3–4–2 не подходит, так как домик _a_ оказывается не посещенным.

Во втором примере не существует способа добраться от домика _b_ до домика _c_, поэтому искомого пути не существует.

### [Решение](F.cpp)


## G. Бемби

  ограничение по времени на тест: 2 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  ввод: стандартный ввод
  
  вывод: стандартный вывод
  
Существует страна, в которой _n_ городов. Города пронумерованы от 1 до _n_. Также в этой стране существуют двунаправленные дороги. Каждая дорога соединяет пару городов. Для каждого _i_, автомобильная дорога _i_ соединяет города _ai_ и _bi_.

Бемби — это олень, который любит путешествовать по дорогам. Движение по дороге _i_ (в любом направлении) занимает у оленя _di_ минут. Бемби ненавидит города и из-за этого никогда в них не задерживается.

Бемби начинает путешествие из города номер 1. Через _t_ минут он желает оказаться в городе _n_. Вы должны узнать, может ли Бемби достигнуть город _n_ ровно через _t_ минут.

### Входные данные

Первая строка содержит два целых числа _n_ и _m_ — количество городов и дорог в стране (1 ≤ _n_, _m_ ≤ 50).

Следующие _m_ строк описывают дороги. Каждая строка состоит из чисел _ai_, _bi_ и _di_ — концы дороги и ее длина (1 ≤ _ai_, _bi_ ≤ _n_; 1 ≤ _di_ ≤ 10^4).

Последняя строка содержит целое число _t_ — количество минут, за которое Бемби желает добраться до города _n_ (1 ≤ _t_ ≤ 10^18).

### Выходные данные

Выведите "Possible" если Бемби сможет достичь цели ровно за _t_ минут, иначе выведите "Impossible".

### Примеры

**входные данные**
```c++
3 3
1 3 7
1 2 6
2 3 5
11
```
**выходные данные**
```c++
Possible
```

**входные данные**
```c++
3 3
1 3 7
1 2 6
2 3 5
25
```
**выходные данные**
```c++
Possible
```

**входные данные**
```c++
2 1
1 2 1
9
```
**выходные данные**
```c++
Possible
```

**входные данные**
```c++
2 1
2 1 1
1000000000000000000
```
**выходные данные**
```c++
Impossible
```

**входные данные**
```c++
4 3
1 3 10
1 2 10
2 3 10
1000
```
**выходные данные**
```c++
Impossible
```

### [Решение](G.cpp)


## H. Карликовая башня

  ограничение по времени на тест: 3 секунды
  
  ограничение по памяти на тест: 256 мегабайт
  
  **ввод: dwarf.in**
  
  **вывод: dwarf.out**
  
Маленький Вася играет в новую игру, которая называется «Карликовая башня». В этой игре
есть _n_ различных предметов, которые можно надеть на героя. Предметы занумерованы числами от
1 до _n_. Вася хочет получить предмет с номером 1.
Есть два способа получить предмет:
• Можно купить предмет. _i_-й предмет стоит _ci_ денег.
• Можно изготовить предмет. Эта игра поддерживает только _m_ типов производства. Чтобы
произвести предмет, нужно отдать два различных предмета и получить один в качестве результата.
Помогите Васе потратить минимальное количество денег, чтобы получить предмет с номером 1.

### Входные данные

Первая строка содержит два целых числа _n_ и _m_ (1 ⩽ _n_ ⩽ 10 000; 0 ⩽ _m_ ⩽ 100 000) — количество
различных предметов и типов производства, соответственно.
Вторая строка содержит _n_ целых чисел _ci_ — стоимости предметов (0 ⩽ _ci_ ⩽ 10^9).
Следующие _m_ строк описывают типы производства, каждая строка состоит из трех различных
целых чисел _ai_, _xi_, _yi_ — предмет _ai_ можно получить из предметов _xi_ и _yi_ (1 ⩽ _ai_, _xi_, _yi_ ⩽ _n; _ai_ ̸= _xi_; _xi_ ̸=_yi_; _yi_ ̸= _ai_).

### Выходные данные

Выведите одно целое число: минимальное количество денег.

### Примеры

**входные данные**
```c++
5 3
5 0 1 2 5
5 2 3
4 2 3
1 4 5
```
**выходные данные**
```c++
2
```

### [Решение](H.cpp)
