
#  Куча, сортировки, двоичный поиск 

## A. Хип ли?

Имя входного файла: isheap.in

Имя выходного файла: isheap.out

Структуру данных Heap можно реализовать на основе массива.

Для этого должно выполнятся _основное свойство Heap’a_, которое заключается в следующем.

Для каждого 0 ≤ _i_ < _n_ выполняются следующие условия:

* Если 2_i_ + 1 < _n_, то _a_[_i_] ≤ _a_[2_i_ + 1]
* Если 2_i_ + 2 < _n_, то _a_[_i_] ≤ _a_[2_i_ + 2]

Дан массив целых чисел. Определите является ли он Heap’ом.

### Формат входного файла

Первая строка входного файла содержит целое число _n_ ( 1 ≤ _n_ ≤ 10^5 ). Вторая строка содержит
_n_ целых чисел по модулю не превосходящих 2 · 10^9.

### Формат выходного файла

Выведите "YES", если массив является Heap’ом и "NO" в противном случае.

### Пример

**isheap.in**
```c++
5
1 0 1 2 0
```

**isheap.out**
```c++
NO
```

**isheap.in**
```c++
5
1 3 2 5 4
```

**isheap.out**
```c++
YES
```

## B. Приоритетная очередь

Имя входного файла: priorityqueue.in

Имя выходного файла: priorityqueue.out

Реализуйте приоритетную очередь. Ваша очередь должна поддерживать следующие операции:
добавить элемент, извлечь минимальный элемент, уменьшить элемент, добавленный во время одной
из операций.
Все операции нумеруются по порядку, начиная с 1.

### Формат входного файла

Входной файл содержит описание операций со очередью. В очередь помещаются и извлекаются
только целые числа, не превышающие по модулю 10^9.

### Формат выходного файла

Выведите последовательно результат выполнения всех операций **extract-min**. Если перед
очередной операции **extract-min** очередь пуста, выведите вместо числа звездочку.

### Пример

**priorityqueue.in**
```c++
push 3
push 4
push 2
extract-min
decrease-key 2 1
extract-min
extract-min
extract-min
```

**priorityqueue.out**
```c++
2
1
3
*
```

### [Решение](B.cpp)

## C. Cортировка

Имя входного файла: sort.in

Имя выходного файла: sort.out

Дан массив целых чисел. Ваша задача - отсортировать его в порядке неубывания.
Для того, чтобы узнать, какую сортировку вам нужно реализовать, возьмите остаток от деления
вашего номера на 3.

* 0 - Сортировка слиянием.
* 1 - Сортировка кучей.
* 2 - Быстрая сортировка.

### Формат входного файла

В первой строке входного файла содержится число _n_ ( 1 ≤ _n_ ≤ 100000 ) - количество элементов
в массиве. Во второй строке находятся _n_ целых чисел, по модулю не превосходящих 10^9.

### Формат выходного файла

В выходной файл надо вывести этот же массив в порядке неубывания, между любыми двумя
числами должен стоять ровно один пробел.

### Пример

**sort.in**
```c++
10
1 8 2 1 4 7 3 2 3 6
```

**sort.out**
```c++
1 1 2 2 3 3 4 6 7 8
```


## D. Цифровая сортировка

Имя входного файла: radixsort.in

Имя выходного файла: radixsort.out

Дано _n_ строк, выведите их порядок после _k_ фаз цифровой сортировки.

### Формат входного файла

В первой строке входного файла содержится число _n_ - количество строк, _m_ - их длина и _k_ –
число фаз цифровой сортировки ( 1 ≤ _n_ ≤ 1000 , 1 ≤ _k_ ≤ _m_ ≤ 1000 ). В следующих _n_ строках
находятся сами строки.

### Формат выходного файла

Выведите строки в порядке в котором они будут после _k_ фаз цифровой сортировки.

### Пример

**radixsort.in**
```c++
3 3 1
bbb
aba
baa
```

**radixsort.out**
```c++
aba
baa
bbb
```

**radixsort.in**
```c++
3 3 2
bbb
aba
baa
```

**radixsort.out**
```
baa
aba
bbb
```

**radixsort.in**
```c++
3 3 3
bbb
aba
baa
```

**radixsort.out**
```c++
aba
baa
bbb
```

### [Решение](D.cpp)

## E. Анти-QuickSort

Имя входного файла: antiqs.in

Имя выходного файла: antiqs.out

Для сортировки последовательности чисел широко используется быстрая сортировка - Quick
Sort. Далее приведена программа, которая сортирует массив _a_, используя этот алгоритм.

```c++
def qsort ( l e f t , right ) :
key = a [ ( l e f t + right ) // 2]
i = l e f t
j = right
while i <= j :
while a [ i ] < key : # f i r s t while
i += 1
while a [ j ] > key : # second while
j −= 1
i f i <= j :
a [ i ] , a [ j ] = a [ j ] , a [ i ]
i += 1
j −= 1
i f l e f t < j :
qsort ( l e f t , j )
i f i < right :
qsort ( i , right )
qsort (0 , n − 1)
```

Хотя QuickSort является самой быстрой сортировкой в среднем, существуют тесты, на которых
она работает очень долго. Оценивать время работы алгоритма будем количеством сравнений
с элементами массива (то есть суммарным количеством сравнений в первом и втором while).
Требуется написать программу, генерирующую тест, на котором быстрая сортировка сделает
наибольшее число таких сравнений.

### Формат входного файла

В первой строке находится единственное число _n_ ( 1 ≤ _n_ ≤ 70000 ).

### Формат выходного файла

Вывести перестановку чисел от 1 до _n_, на которой быстрая сортировка выполнит максимальное
число сравнений. Если таких перестановок несколько, вывести любую из них.

### Пример

**antiqs.in**
```c++
3 
```

**antiqs.out**
```c++
1 3 2
```

### [Решение](E.cpp)

## F. Стильная одежда

Имя входного файла: style.in

Имя выходного файла: style.out

Глеб обожает шоппинг. Как-то раз он загорелся идеей подобрать себе майку и штаны так, чтобы
выглядеть в них максимально стильно. В понимании Глеба стильность одежды тем больше, чем
меньше разница в цвете элементов его одежды.
В наличии имеетсяN ( 1 ≤ _N_ ≤ 100 000) маек и _M_ ( 1 ≤ _M_ ≤ 100 000) штанов, про каждый
элемент известен его цвет (целое число от 1 до 10 000 000). Помогите Глебу выбрать одну майку и
одни штаны так, чтобы разница в их цвете была как можно меньше.

### Формат входного файла

Сначала вводится информация о майках: в первой строке целое число _N_ ( 1 ≤ _N_ ≤100 000) и во
второй _N_ целых чисел от 1 до 10 000 000 - цвета имеющихся в наличии маек. **Гарантируется**, что
номера цветов идут в возрастающем порядке (в частности, цвета никаких двух маек не совпадают).
Далее в том же формате идёт описание штанов: их количество _M_ ( 1 ≤ _M_ ≤ 100 000) и в
следующей строке _M_ целых чисел от 1 до 10 000 000 в возрастающем порядке - цвета штанов.

### Формат выходного файла

Выведите пару неотрицательных чисел - цвет майки и цвет штанов, которые следует выбрать
Глебу. Если вариантов выбора несколько, выведите любой из них.

### Примеры

**style.in**
```c++
2
3 4
3
1 2 3
```

**style.out**
```c++
3 3
```

**style.in**
```c++
2
4 5
3
1 2 3
```

**style.out**
```c++
4 3
```

### [Решение](F.cpp)

## G. Стильная одежда 2

Имя входного файла: style.in

Имя выходного файла: style.out

Глеб решил развить успех и купить более сложный комплект: из кепки, майки, штанов и ботинок.
В понимании Глеба стильность комплекта тем больше, чем меньше максимальная разница в цвете
элементов его одежды.
В наличии имеется _N1_ кепок, _N2_ маек, _N3_ штанов и _N4_ ботинок, про каждый элемент известен
его цвет. Помогите Глебу выбрать комплект.

### Формат входного файла

Сначала вводится информация о кепках, потом о майках, потом о штанах и в конце о ботинках:.
Про каждый тип одежды в первой строке целое число _Ni_ ( 1 ≤ _Ni_ ≤ 100 000) и во второй _Ni_ целых
чисел от 1 до 100 000 - цвета имеющихся предметов.

### Формат выходного файла

Выведите четыре числа - цвета кепки, майки, штанов и ботинок. Если вариантов выбора
несколько, выведите любой из них.

### Примеры

**style.in**
```c++
3
1 2 3
2
1 3
2
3 4
2
2 3
```

**style.out**
```c++
3 3 3 3
```

**style.in**
```c++
1
5
4
3 6 7 10
4
18 3 9 11
1
20
```

**style.out**
```c++
5 7 9 20
```

### [Решение](G.cpp)

## H. K-ая порядковая статистика

Имя входного файла: kth.in

Имя выходного файла: kth.out

Дан массив изnэлементов. Какое число _k_-ое в порядке возрастания в этом массиве.

### Формат входного файла

В первую строке входного файла содержится два числа _n_ - размер массива и
_k_.( 1 ≤ _k_ ≤ _n_ ≤ 3 · 10^7 ). Во второй строке находятся числа _A_, _B_, _C_, _a1_ , _a2_ по модулю не
превосходящие 10^9. Вы должны получить элементы массива начиная с третьего по формуле:
_ai_ = _A_ ∗ _ai−2_ + _B_ ∗ _ai−1_ + _C_. Все вычисления должны производится в 32 битном знаковом типе,
переполнения должны игнорироваться.

### Формат выходного файла

Выведите значение _k_-ое в порядке возрастания число в массиве _a_.

### Пример

**kth.in**
```c++
5 3
2 3 5 1 2
```

**kth.out**
```c++
13
```

**kth.in**
```c++
5 3
200000 300000 5 1 2
```

**kth.out**
```c++
2
```

Во втором примере элементы массива _a_ равны: ( 1 , 2 , 800005 ,− 516268571 , 1331571109 ).

### [Решение](H.cpp)

## I. Двоичный поиск

Имя входного файла: binsearch.in

Имя выходного файла: binsearch.out

Дан массив из _n_ элементов, упорядоченный в порядке неубывания и _m_ запросов: найти первое
и последнее вхождение числа в массив.

### Формат входного файла

В первую строке входного файла содержится одно число _n_ - размер массива.( 1 ≤ _n_ ≤ 100000 ).
Во второй строке находится _n_ чисел в порядке неубывания - элементы массива. В третьей строке
находится число _m_ - количество запросов. В следующей строке находится _m_ чисел - запросы.

### Формат выходного файла

Для каждого запроса выведите в отдельной строке номер первого и последнего вхождения этого
числа в массив. Если числа в массиве нет выведите два раза -1.

### Пример

**binsearch.in**
```c++
5
1 1 2 2 2
3
1 2 3
```

**binsearch.out**
```c++
1 2
3 5
-1 -1
```

### [Решение](I.cpp)

## J. Гирлянда

Имя входного файла: garland.in

Имя выходного файла: garland.out

Гирлянда состоит из _n_ лампочек на общем проводе. Один её конец закреплён на заданной высоте
_A_ мм (_h1_ = _A_). Благодаря силе тяжести гирлянда прогибается: высота каждой неконцевой лампы
на 1 мм меньше, чем средняя высота ближайших соседей (_hi_ = (_hi−1_ + _hi+1_)/2 − 1 для 1 < _i_ < _N_).
Требуется найти минимальную высоту второго конца _B_ (_B_ = _hn_) при условии, что ни одна из
лампочек не должна лежать на земле (_hi_ > 0 для 1 ≤ _i_ ≤ _N_).

### Формат входного файла

В первую строке входного файла содержится два числа _n_ и _A_ ( 3 ≤ _n_ ≤ 1000 , n - целое,
10 ≤ _A_ ≤ 1000 ,A - вещественное).

### Формат выходного файла

Вывести одно вещественное число _B_ с двумя знаками после запятой.

### Пример

**garland.in**
```c++
8 15
```

**garland.out**
```c++
9.75
```

**garland.in**
```c++
692 532.81 
```

**garland.out**
```c++
446113.34
```

### [Решение](J.cpp)

## K. Поезда

Имя входного файла: trains.in

Имя выходного файла: trains.out

  В связи с участившимся числом аварий на железнодорожной ветке Москва–Саратов,
руководство железной дороги решило изменить график движения поездов. Тщательный анализ
состояния железнодорожного полотна показал, что оптимальным является следующий график
движения поездов с учетом остановок на станциях: сначала поезд идет на протяжении _T1_ минут
со скоростью _V1_ метров в минуту, затем _T2_ минут со скоростью _V2_ метров в минуту, ..., наконец,
_TN_ минут со скоростью _VN_ метров в минуту. В течение некоторых интервалов поезд может стоять
(скорость равна 0).
  По действующей инструкции обеспечения безопасности движения поездов расстояние между
локомотивами двух следующих друг за другом поездов должно быть не менее _L_ метров. Определите
минимально допустимый интервал в минутах между отправлениями поездов, позволяющий им
двигаться по этому графику без опасного сближения.

### Формат входного файла

В первых двух строках входного файла содержится два натуральных числа, задающие
минимально допустимое расстояние _L_ и количество участков пути _N_ ( 100 ≤ _L_ ≤ 10 000,
1 ≤ _N_ ≤ 1000 ). Далее следует _N_ пар целых чисел _Ti_ и _Vi_, задающих график движения поездов
( 1 ≤ _Ti_ ≤ 1000 , 0 ≤ _Vi_ ≤ 1000 ).

### Формат выходного файла

В выходной файл необходимо вывести искомый интервал между отправлениями поездов в
минутах, не менее чем с тремя верными знаками после десятичной точки.

### Пример

**trains.in**
```c++
1000
4
10 0
30 80
15 0
20 100
```

**trains.out**
```c++
27.500
```

### [Решение](K.cpp)
