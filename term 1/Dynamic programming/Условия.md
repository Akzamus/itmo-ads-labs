# Динамическое программирование

## A. Кузнечик собирает монеты

Имя входного файла: input.txt

Имя выходного файла: output.txt

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Кузнечик прыгает по столбикам, расположенным на одной линии на равных расстояниях друг
от друга. Столбики имеют порядковые номера от 1 до _N_. В начале Кузнечик сидит на столбике с
номером 1. Он может прыгнуть вперед на расстояние от 1 до _K_ столбиков, считая от текущего.
На каждом столбике Кузнечик может получить или потерять несколько золотых монет (для
каждого столбика это число известно). Определите, как нужно прыгать Кузнечику, чтобы собрать
наибольшее количество золотых монет. Учитывайте, что Кузнечик не может прыгать назад.

### Формат входных данных

В первой строке вводятся два натуральных числа: _N_ и _K_ ( 2 ⩽ _N_, _K_ ⩽ 10000 ), разделённые
пробелом. Во второй строке записаны через пробел _N_-2 целых числа - количество монет, которое
Кузнечик получает на каждом столбике, от 2-го до _N_-1-го. Если это число отрицательное, Кузнечик
теряет монеты. Гарантируется, что все числа по модулю не превосходят 10 000.

### Формат выходных данных

В первой строке программа должна вывести наибольшее количество монет, которое может со
брать Кузнечик. Во второй строке выводится число прыжков Кузнечика, а в третьей строке - номера
всех столбиков, которые посетил Кузнечик (через пробел в порядке возрастания).
Если правильных ответов несколько, выведите любой из них.

### Пример

**input.txt**
```c++
5 3
2 -3 5
```

**output.txt**
```c++
7
3
1 2 4 5
```

### [Решение](A.java)

## B. Наибольшая возрастающая подпоследовательность

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Пусть _a1_, _a2_, ..., _an_ — числовая последовательность. Длина последовательности — это количество
элементов этой последовательности. Последовательность _ai1_, _ai2_, ..., _aik_ называется подпоследова
тельностью последовательности _a_, если 1 ⩽ _i1_ < _i2_ < ... < _ik_ ⩽ _n_. Последовательность _a_ называется
возрастающей, если _a1_ < _a2_ < ... < _an_.
Вам дана последовательность, содержащая _n_ целых чисел. Найдите ее самую длинную возрас
тающую подпоследовательность.

### Система оценки

Подзадача 1 (60 баллов) _n_ ⩽ 300

Подзадача 2 (40 баллов) _n_ ⩽ 2 000

## Формат входных данных

В первой строке задано одно число _n_ ( 1 ⩽ _n_ ⩽ 2000 ) — длина подпоследовательности. В следу
ющей строке задано _n_ целых чисел _ai_ ( 10^9 ⩽ _ai_ ⩽ 10^9 ) — элементы последовательности.

### Формат выходных данных

В первой строке выведите число _k_ — длину наибольшей возрастающей подпоследовательности.
В следующей строке выведите _k_ чисел — саму подпоследовательность.

### Примеры

**стандартный ввод**
```c++
5
1 3 5 4 2
```

**стандартный вывод**
```c++
3
1 3 5
```

**стандартный ввод**
```c++
3
1 2 3
```

**стандартный вывод**
```c++
3
1 2 3
```

### [Решение](В.java)

## C. Ход конем

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 1 секунда

Ограничение по памяти: 256 мегабайт

Шахматная ассоциация решила оснастить всех своих сотрудников такими телефонными номера-
ми, которые бы набирались на кнопочном телефоне ходом коня. Например, ходом коня набирается
телефон 340-49-27. При этом телефонный номер не может начинаться ни с цифры 0, ни с цифры 8.

```
1 2 3
4 5 6
7 8 9
. 0 .
```

Напишите программу, определяющую количество телефонных номеров длины _N_, набираемых
ходом коня. Поскольку таких номеров может быть очень много, выведите ответ по модулю 10^9.

### Формат входных данных

Во входном файле записано целое число _N_ ( 1 ⩽ _N_ ⩽ 100 ).

## Формат выходных данных

Выведите в выходной файл искомое количество телефонных номеров по модулю 10^9.

### Примеры

**стандартный ввод**
```c++
1
```

**стандартный вывод**
```c++
8
```

**стандартный ввод**
```c++
2
```

**стандартный вывод**
```c++
16
```

### [Решение](C.java)

## D. Расстояние по Левенштейну

Имя входного файла: input.txt

Имя выходного файла: output.txt

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дана текстовая строка. С ней можно выполнять следующие операции:
1. Заменить один символ строки на другой символ.
2. Удалить один произвольный символ.
3. Вставить произвольный символ в произвольное место строки.

Например, при помощи первой операции из строки "СОК"можно получить строку "СУК при
помощи второй операции - строку "ОК при помощи третьей операции - строку "СТОК.
Минимальное количество таких операций, при помощи которых можно из одной строки получить
другую, называется стоимостью редактирования или расстоянием Левенштейна.
Определите расстояние Левенштейна для двух данных строк.

### Формат входных данных

Программа получает на вход две строки, длина каждой из которых не превосходит 1000 симво
лов, строки состоят только из заглавных латинских букв.

### Формат выходных данных

Требуется вывести одно число - расстояние Левенштейна для данных строк.

### Пример

**input.txt**
```c++
ABCDEFGH
ACDEXGIH
```

**output.txt**
```c++
3
```

### [Решение](D.java)

## E. Кафе

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 64 мегабайта

Около Петиного университета недавно открылось новое кафе, в котором действует следующая
система скидок: при каждой покупке более чем на 100 рублей покупатель получает купон, дающий
право на один бесплатный обед (при покупке на сумму 100 рублей и меньше такой купон покупатель
не получает).
Однажды Пете на глаза попался прейскурант на ближайшие _n_ дней. Внимательно его изучив,
он решил, что будет обедать в этом кафе всеnдней, причем каждый день он будет покупать в
кафе ровно один обед. Однако стипендия у Пети небольшая, и поэтому он хочет по максимуму ис
пользовать предоставляемую систему скидок так, чтобы его суммарные затраты были минимальны.
Требуется найти минимально возможную суммарную стоимость обедов и номера дней, в которые
Пете следует воспользоваться купонами.

### Формат входных данных

В первой строке входного файла записано целое числоn( 0 ⩽ _n_ ⩽ 100 ). В каждой из последующих
nстрок записано одно целое число, обозначающее стоимость обеда в рублях на соответствующий
день. Стоимость — неотрицательное целое число, не превосходящее 300.

### Формат выходных данных

В первой строке выдайте минимальную возможную суммарную стоимость обедов. Во второй
строке выдайте два числа _k1_ и _k2_ — количество купонов, которые останутся неиспользованными у
Пети после этих _n_ дней и количество использованных им купонов соответственно.
В последующих _k2_ строках выдайте в возрастающем порядке номера дней, когда Пете следует
воспользоваться купонами. Если существует несколько решений с минимальной суммарной стоимо
стью, то выдайте то из них, в котором значение _k1_ максимально (на случай, если Петя когда-нибудь
ещё решит заглянуть в это кафе). Если таких решений несколько, выведите любое из них.

### Примеры

**стандартный ввод**
```c++
5
110
40
120
110
60
```

**стандартный вывод**
```c++
260
0 2
3
5
```

**стандартный ввод**
```c++
3
110
110
110
```

**стандартный вывод**
```c++
220
1 1
2
```

### [Решение](E.java)

## F. Удаление скобок 2.

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дана строка, составленная из круглых, квадратных и фигурных скобок. Определите, какое наи-
меньшее количество символов необходимо удалить из этой строки, чтобы оставшиеся символы об-
разовывали правильную скобочную последовательность.

### Формат входных данных

Во входном файле записана строка из круглых, квадратных и фигурных скобок. Длина строки
не превосходит 100 символов.

### Формат выходных данных

Выведите максимальную длину строки, являющуюся правильной скобочной последовательно-
стью, которую можно получить из исходной строки удалением некоторых символов.

### Пример

**стандартный ввод**
```c++
([)]
```

**стандартный вывод**
```c++
2
```

### [Решение](F.java)

## G. Удаление скобок 2.

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дана строка, составленная из круглых, квадратных и фигурных скобок. Определите, какое наи
меньшее количество символов необходимо удалить из этой строки, чтобы оставшиеся символы об
разовывали правильную скобочную последовательность.

### Формат входных данных

Во входном файле записана строка из круглых, квадратных и фигурных скобок. Длина строки
не превосходит 100 символов.

### Формат выходных данных

Выведите строку максимальной длины, являющейся правильной скобочной последовательно-
стью, которую можно получить из исходной строки удалением некоторых символов.

### Пример

**стандартный ввод**
```c++
([)]
```

**стандартный вывод**
```c++
[]
```

### [Решение](G.java)

## H. Выбор вершин дерева

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дан граф, являющийся деревом. Множество вершин графа называется _допустимым_, если ни
какие две вершины этого множества не соединены ребром.
Рассмотрим все допустимые множества вершин графа. Для каждого такого множества посчитаем
количество вершин в нём. Каково максимальное из этих количеств?

### Формат входных данных

Граф в этой задаче задан в виде _корневого дерева_. В графе выделена вершина — _корень дерева_.
Для каждой вершины _i_, не являющейся корнем, задан номер вершины-предка _pi_ в корневом дереве.
Дерево, заданное таким образом, состоит из рёбер _i_—_pi_ для всех вершин _i_, кроме корня.
В первой строке входного файла записано целое число _n_ — количество вершин в графе
( 1 ⩽ _n_ ⩽ 100 ). В следующих _n_ строках задан граф. В _i_-й из этих строк записано целое число
 _pi_ — номер вершины-предка _i_-й вершины. Для корня дерева _pi_ = 0; для всех остальных вершин
1 ⩽ _pi_ ⩽ _n_.
Гарантируется, что заданный во входном файле граф является деревом.

### Формат выходных данных

В первой строке выходного файла выведите одно число — максимальное количество вершин в
допустимом множестве.

### Примеры

**стандартный ввод**
```c++
5 
0 
1 
1 
2 
3
```

**стандартный вывод**
```c++
3
```
**стандартный ввод**
```c++
6 
5 
6 
5
1
0
1
```

**стандартный вывод**
```c++
3
```

### [Решение](H.java)

## I. Паросочетание

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

  _Двудольным графом_ называется неориентированный граф (_V_, _E_), _E_ ⊆ _V_ × _V_ такой, что его
множество вершин _V_ можно разбить на два множества _A_ и _B_, для которых ∀(_e1_ , _e2_ ) ∈ E _e1_ ∈ _A_,
_e2_ ∈ _B_ и _A_ ∪ _B_ = _V_, _A_ \ _B_ = ∅.
  _Паросочетанием_ в двудольном графе называется любой набор его несмежных рёбер, то есть
такой набор _S_ ⊆ _E_, что для любых двух рёбер _e1_ = ( _u1_, _v1_), _e2_ = ( _u2_, _v2_) из _S_ _u1_ ≠ _u2_ и _v1_ ≠  _v2_.
Ваша задача — найти максимальное паросочетание в двудольном графе, то есть паросочетание
с максимально возможным числом рёбер.

### Формат входных данных

В первой строке записаны два целых числа _n_ и _m_ ( 1 ⩽ _n_, _m_ ⩽ 250 ), где _n_ — число вершин
в множестве _A_, а _m_ — число вершин в _B_.
Далее следуют _n_ строк с описаниями рёбер — _i_-я вершина из _A_ описана в (_i_+1)-й строке файла.
Каждая из этих строк содержит номера вершин из _B_, соединённых с _i_-й вершиной _A_. Гарантируется,
что в графе нет кратных ребер. Вершины в _A_ и _B_ нумеруются независимо (с единицы). Список
завершается числом 0.

### Формат выходных данных

Первая строка выходного файла должна содержать одно целое число _l_ — количество рёбер в мак
симальном паросочетании. Далее следуют _l_ строк, в каждой из которых должны быть два целых
числа _uj_ и _vj_ — концы рёбер паросочетания в _A_ и _B_ соотвественно.

### Пример

**стандартный ввод**
```c++
2 2
1 2 0
2 0
```

**стандартный вывод**
```c++
2
1 1
2 2
```

### [Решение](I.java)

## J. Продавец аквариумов

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 1 секунда

Ограничение по памяти: 256 мегабайт

Продавец аквариумов для кошек хочет объехать _n_ городов, посетив каждый из них ровно один
раз. Помогите ему найти кратчайший путь.

### Формат входных данных

Первая строка входного файла содержит натуральное число _n_ ( 1 ⩽ _n_ ⩽ 13 ) — количество горо
дов. Следующие _n_ строк содержат по _n_ чисел — длины путей между городами.
В _i_-й строке _j_-е число — _ai,j_— это расстояние между городами _i_ и _j_ ( 0 ⩽ _ai,j_⩽ 10^6 ; _ai,j_ = _aj,i_;
_ai,i_ = 0).

### Формат выходных данных

В первой строке выходного файла выведите длину кратчайшего пути. Во второй строке выведите
nчисел — порядок, в котором нужно посетить города.

### Примеры

**стандартный ввод**
```c++
5
0 183 163 173 181
183 0 165 172 171
163 165 0 189 302
173 172 189 0 167
181 171 302 167 0
```

**стандартный вывод**
```c++
666
4 5 2 3 1
```

### [Решение](J.java)

## K. Симпатичные узоры

Имя входного файла: nice.in

Имя выходного файла: nice.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Компания _BrokenTiles_ планирует заняться выкладыванием во дворах у состоятельных клиентов
узор из черных и белых плиток, каждая из которых имеет размер 1 × 1 метр. Известно, что дворы
всех состоятельных людей имеют наиболее модную на сегодня форму прямоугольника _n_ × _m_ метров.
Однако при составлении финансового плана у директора этой организации появилось целых две
серьезных проблемы: во первых, каждый новый клиент очевидно захочет, чтобы узор, выложенный
у него во дворе, отличался от узоров всех остальных клиентов этой фирмы, а во вторых, этот узор
должен быть симпатичным.
Как показало исследование, узор является симпатичным, если в нем нигде не встречается квад
рата 2 × 2 метра, полностью покрытого плитками одного цвета.
Для составления финансового плана директору необходимо узнать, сколько клиентов он сможет
обслужить, прежде чем симпатичные узоры данного размера закончатся. Помогите ему!

### Формат входных данных

На первой строке входного файла находятся два натуральных числаnиm. 1 ⩽ _n_ * _m_ ⩽ 30.

### Формат выходных данных

Выведите в выходной файл единственное число — количество различных симпатичных узоров,
которые можно выложить во дворе размера _n_ × _m_. Узоры, получающиеся друг из друга сдвигом,
поворотом или отражением считаются различными.

### Примеры

**nice.in**
```c++
1 1 
```

**nice.out**
```c++
2
```

**nice.in**
```c++
1 2 
```

**nice.out**
```c++
4
```

### [Решение](K.java)

## L. Cows in a Skyscraper

Имя входного файла: skyscraper.in

Имя выходного файла: skyscraper.out

Ограничение по времени: 1 секунда

Ограничение по памяти: 256 мегабайт

Коровы любят соревноваться в беге по лестницам небоскребов. А вниз потом едут на лифте.
Лифт имеет максимальную вместимостьw( 1 ⩽ _w_ ⩽ 10^8 ) фунтов, а корова номер _i_ весит _ci_
( 1 ⩽ _ci_ ⩽ _w_) фунтов.
Помогите Бесси определить минимальное количество спусков лифта, чтобы переместить вниз
всеn( 1 ⩽ _n_ ⩽ 18 ) коров.
Сумма весов коров в каждом спуске не должна превышать _W_.

### Формат входных данных

Первая строка содержит два целых числа _n_ и _w_ ( 1 ⩽ _n_ ⩽ 18 ; 1 ⩽ _w_ ⩽ 10^8 ).
Следующие _n_ строк содержат веса коров: _i_-я строк содержит целое число _ci_ ( 1 ⩽ _ci_ ⩽ _w_).

### Формат выходных данных

Первая строка должна содержать число _r_ — минимально количество спусков лифта.
Каждая из следующих _r_ строк содержит множество коров, которые сейчас спускаются. Строка
начинается с количество коров на данном спуске, далее содержатся номера коров.

### Примеры

**skyscraper.in**
```c++
4 10
5
6
3
7
```

**skyscraper.out**
```c++
3
2 1 3
1 2
1 4
```

### Замечание

Всего 4 коровы с весами 5 6 3 и 7. Вместимость лифта — 10.
Мы можем поместить в лифт корову 3 и любую из оставшихся коров. Но все другие коровы не
помещаются даже по две. В решении представленном выше, в первом спуске участвуют коровы 1
и 3, Во втором — корова 2, в третьем — корова 4. Существует несколько правильных решений для
данного ввода.
