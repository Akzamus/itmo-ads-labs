# Дерево отрезков

## A. Сумма простая

Имя входного файла: sum0.in

Имя выходного файла: sum0.out

Ограничение по времени: 1 секунда

Ограничение по памяти: 256 мегабайт

Вам нужно научиться отвечать на запрос «сумма чисел на отрезке».
Массив не меняется. Запросов много. Отвечать на каждый запрос следует за _O_(1).

### Формат входных данных

Размер массива — _n_ и числа _x_, _y_, _a0_ , порождающие массив _a_: _ai_= (x * _a{i-1}_ + _y_) mod 2^16
Далее следует количество запросовmи числа _z_, _t_, _b0_, порождающие массив _b_: _bi_ = (_z_ * {_bi-1} + _t_) mod
2^30.

Массив _c_ строится следующим образом: _ci_ =_bi_ mod _n_.
Запросы: _i_-й из них — найти сумму на отрезке от min(_c2i_; _c2{i+1}_) до max(_c2i_; _c2{i+1}_) в массиве _a_.
Ограничения: 1 ⩽ _n_ ⩽ 10^7 , 0 ⩽ _m_ ⩽ 10^7. Все числа целые от 0 до 2^16. _t_ может быть равно -1.

### Формат выходных данных

Выведите сумму всех сумм.

### Пример

**sum0.in**
```c++
3 1 2 3
3 1 -1 4
```

**sum0.out**
```c++
23
```

### Замечание
_a_ = { 3, 5, 7}, _b_ = { 4, 3, 2, 1, 0, 2^30 - 1}, _c_ = { 1, 0, 2, 1, 0, 0},
запросы = { [0;1], [1;2], [0;0]}, суммы = { 8, 12, 3}.

### [Решение](A.cpp)

## B. RSQ

Имя входного файла: rsq.in

Имя выходного файла: rsq.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

### Формат входных данных

В первой строке находится число _n_ — размер массива. ( 1 ⩽ _n_ ⩽ 500,000) Во второй строке
находится _n_ чисел _ai_ — элементы массива. Далее содержится описание операций, их количество не
превышает 1,000,000. В каждой строке находится одна из следующих операций:

 * set _i_ _x_ — установить _a_[_i_] в _x_.

 * sum _i_ _j_ — вывести значение суммы элементов в массиве на отрезке _сi_ по _j_, гарантируется, что
( 1 ⩽ _i_ ⩽ _j_ ⩽ _n_).

Все числа во входном файле и результаты выполнения всех операций не превышают по модулю 10^18.

### Формат выходных данных

Выведите последовательно результат выполнения всех операций sum. Следуйте формату выход-
ного файла из примера.

### Пример

**rsq.in**
```с++ 
5
1 2 3 4 5
sum 2 5
sum 1 5
sum 1 4
sum 2 4
set 1 10
set 2 3
set 5 2
sum 2 5
sum 1 5
sum 1 4
sum 2 4
```

**rsq.out**
```c++
14
15
10
9
12
22
20
10
```

### [Решение](B.cpp)

## Задача C. RMQ


Имя входного файла: rmq2.in

Имя выходного файла: rmq2.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

### Формат входных данных

В первой строке находится число _n_ — размер массива. ( 1 ⩽ _n_ ⩽ 10^5 ) Во второй строке находится
_n_ чисел _ai_ — элементы массива. Далее содержится описание операций, их количество не превышает
2 * 10^5. В каждой строке находится одна из следующих операций:

* set _i_ _j_ _x_ — установить все _a_[_k_], _i_ ⩽ _k_ ⩽ _j_ в _x_.

* add _i_ _j_ _x_ — увеличить все _a_[_k_], _i_ ⩽ _k_ ⩽ _j_ на _x_.

* min _i_ _j_ — вывести значение минимального элемента в массиве на отрезке _сi_ по _j_, гарантируется,
что ( 1 ⩽ _i_ ⩽ _j_ ⩽ _n_).

Все числа во входном файле и результаты выполнения всех операций не превышают по модулю 10^18.

### Формат выходных данных

Выведите последовательно результат выполнения всех операций min. Следуйте формату выход
ного файла из примера.

### Пример

**rmq2.in**
```c++
5
1 2 3 4 5
min 2 5
min 1 5
min 1 4
min 2 4
set 1 3 10
add 2 4 4
min 2 5
min 1 5
min 1 4
min 2 4
```
**rmq2.out**
```c++
2
1
1
2
5
5
8
8
```

### [Решение](C.cpp)

## D. Художник

Имя входного файла: painter.in

Имя выходного файла: painter.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Итальянский художник-абстракционист Ф. Мандарино увлекся рисованием одномерных черно
белых картин. Он пытается найти оптимальное местоположение и количество черных участков кар
тины. Для этого он проводит на прямой белые и черные отрезки, и после каждой из таких операций
хочет знать количество черных отрезков на получившейся картине и их суммарную длину.
Изначально прямая — белая. Ваша задача — написать программу, которая после каждой из
таких операций выводит в выходной файл интересующие художника данные.

### Формат входных данных

В первой строке входного файла содержится общее количество нарисованных отрезков
( 1 ⩽ _n_ ⩽ 100 000). В последующихnстроках содержится описание операций. Каждая операция
описывается строкой вида _c_ _x_ _l_, где _c_ — цвет отрезка (**W** для белых отрезков,**B** для черных), а сам
отрезок имеет вид [_x_; _x_+_l_], причем координаты обоих концов — целые числа, не превосходящие по
модулю 500 000. Длина задается положительным целым числом.

### Формат выходных данных

После выполнения каждой из операций необходимо вывести в выходной файл на отдельной
строке количество черных отрезков на картине и их суммарную длину, разделенные одним пробелом.

### Пример

**painter.in**
```c++
7
W 2 3
B 2 2
B 4 2
B 3 2
B 7 2
W 3 1
W 0 10
```

**painter.out**
```c++
0 0
1 2
1 4
1 4
2 6
3 5
0 0
```

### [Решение](D.cpp)

## E. Криптография

Имя входного файла: crypto.in

Имя выходного файла: crypto.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Задано _n_ матриц _A1_, _A2_,..., _An_ размера 2 * 2. Необходимо для нескольких запросов вычислить
произведение матриц _Ai_, _Ai+1_,..., _Aj_. Все вычисления производятся по модулюr.

### Формат входных данных

Первая строка входного файла содержит числа _r_ ( 1 ⩽ _r_ ⩽ 10 000), _n_ ( 1 ⩽ _n_ ⩽ 200 000) и
_m_ ( 1 ⩽ _m_ ⩽ 200 000). Следующие _n_ блоков по две строки содержащие по два числа в строке —
описания матриц. Затем следуют _m_ пар целых чисел от 1 до _n_, запросы на произведение на отрезке.

### Формат выходных данных

Выведите _m_ блоков по две строки, по два числа в каждой — произведения на отрезках. Разде
ляйте блоки пустой строкой. Все вычисления производятся по модулю _r_.

### Пример

**crypto.in**
```c++
3 4 4
0 1
0 0
2 1
1 2
0 0
0 2
1 0
0 2
1 4
2 3
1 3
2 2
```

**crypto.out**
```c++
0 2
0 0
0 2
0 1
0 1
0 0
2 1
1 2
```

### [Решение](E.cpp)

## F. Разреженные таблицы

Имя входного файла: sparse.in

Имя выходного файла: sparse.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Дан массив изnчисел. Требуется написать программу, которая будет отвечать на запросы сле-
дующего вида: найти минимум на отрезке междуuиvвключительно.

### Формат входных данных

В первой строке входного файла даны три натуральных числаn, _m_ ( 1 ⩽ _n_ ⩽ 10^5 , 1 ⩽ _m_ ⩽ 10^7 ) и
_a1_ ( 0 ⩽ _a1_ < 16 714 589) — количество элементов в массиве, количество запросов и первый элемент
массива соответственно. Вторая строка содержит два натуральных числа _u1_ и _v1_ ( 1 ⩽ _u1_ ; _v1_ ⩽ _n_) —
первый запрос.
Элементы _a2_, _a3_,..., _an_ задаются следующей формулой:

_ai+1_ = (23 * _ai_ + 21563) mod 16714589.


Например, при _n_ = 10, _a1_ = 12345 получается следующий массив: _a_ = ( 12345, 305498, 7048017,
11694653, 1565158, 2591019, 9471233 , 570265, 13137658, 1325095).
Запросы генерируются следующим образом:


_ui+1_ = ((17 * _ui_ + 751 + _ansi_ + _2i_) mod _n_) + 1,


_vi+1_ = ((13 * _vi_ + 593 + _ansi_ + _5i_) mod _n_) + 1,

где _ansi_ — ответ на запрос номер _i_.

Обратите внимание, что _ui_ может быть больше, чем _vi_.

### Формат выходных данных

В выходной файл выведите _um_, _vm_ и _ansm_ (последний запрос и ответ на него).

### Примеры

***sparse.in***
```c++
10 8 12345
3 9
```

**sparse.out**
```c++
5 3 1565158
```

### [Решение](F.cpp)

## G. Окна

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

На экране расположены прямоугольные окна, каким-то образом перекрывающиеся (со сторона-
ми, параллельными осям координат). Вам необходимо найти точку, которая покрыта наибольшим
числом из них.

### Формат входных данных

В первой строке входного файла записано число окон _n_( 1 ⩽ _n_ ⩽ 50000 ). Следующие _n_ строк
содержат координаты окон _x_(1,_i_)_y_(1,_i_)_x_(2,_i_)_y_(2,_i_), где( _x_(1,_i_); y(1;i)) — координаты левого верхнего угла
 _i_-го окна, _а_( _x_(2;_i_), _y_(2;_i_)) — правого нижнего (на экране компьютера _y_ растет сверху вниз, а _x_ — слева
направо). Все координаты — целые числа, по модулю не превосходящие 2 * 10^5.

### Формат выходных данных

В первой строке выходного файла выведите максимальное число окон, покрывающих какую-либо
из точек в данной конфигурации. Во второй строке выведите два целых числа, разделенные пробе
лом — координаты точки, покрытой максимальным числом окон. Окна считаются замкнутыми, т.е.
покрывающими свои граничные точки.

### Примеры

**стандартный ввод**
```c++
2
0 0 3 3
1 1 4 4
```

**стандартный вывод**
```c++
2
1 3
```

**стандартный ввод**
```c++
1
0 0 1 1
```

**стандартный вывод**
```c++
1
0 1
```

### [Решение](G.cpp)

## H. RMQ наоборот

Имя входного файла: rmq.in

Имя выходного файла: rmq.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Рассмотрим массив _a_[1..n]. Пусть _Q_(_i_, _j_) — ответ на запрос о нахождении минимума среди чисел
_a_[_i_],..., a[_j_]. Вам даны несколько запросов и ответы на них. Восстановите исходный массив.

### Формат входных данных

Первая строка входного файла содержит число _n_ — размер массива, и _m_ — число запросов
( 1 ⩽ _n_, _m_ ⩽ 100 000). Следующие _m_ строк содержат по три целых числа _i_, _j_ и _q_, означающих, что
 _Q_(_i_, _j_) = _q_( 1 ⩽ _i_⩽ _j_ ⩽ _n_, -2^31 ⩽ _q_ ⩽ 2^31-1 ).

### Формат выходных данных

Если искомого массива не существует, выведите строку «inconsistent».
В противном случае в первую строку выходного файла выведите «consistent». Во вторую стро-
ку выходного файла выведите элементы массива. Элементами массива должны быть целые числа
в интервале от -2^31 до 2^31-1 включительно. Если решений несколько, выведите любое.

### Примеры

**rmq.in**
```c++
3 2
1 2 1
2 3 2
```

**rmq.out**
```
consistent
1 2 2
```

**rmq.in**
```c++
3 3
1 2 1
1 1 2
2 3 2
```

**rmq.out**
```c++
inconsistent
```

### [Решение](H.cpp)

## I. Горы

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

В парке развлечений «Ай-ой-ай» открылся новейший аттракцион: польские горки. Трек состоит
изnрельс, присоединенных одна к концу другой. Начало первой рельсы находится на высоте 0.
Оператор Петя может конфигурировать аттракцион, изменяя по своему желанию подъём несколь-
ких последовательных рельс. При этом подъём всех остальных рельс не изменяется. При каждом
изменении конфигурации рельс положение следующих за изменяемыми подбирается таким образом,
чтобы весь трек оставался связным.
Каждый запуск вагонетки осуществляется с энергией, достаточной для достижения высотыh.
Это значит, что вагонетка будет двигаться до тех пор, пока высота не превысит _h_, либо пока не
закончится трек.
По записям о всех изменениях конфигурации рельс и временах запусков вагонетки для каждого
запуска определите, сколько рельс вагонетка проедет до остановки.
Трек можно представить как последовательность _n_ подъемов _di_, по одному на рельс. Изначально
рельсы горизонтальны, то есть _di_ = 0 для всех _i_.

Каждое изменение конфигурации определяется числами _a_,_b_ и _D_: все рельсы с _a_-й по _b_-ю вклю-
чительно после этого действия имеют подъем, равный _D_.

Каждый запуск вагонетки определяется единственным целым числом _h_ — максимальной высо-
той, на которую способна подняться вагонетка.

### Формат входных данных


В первой строке записано целое числоn( 1 ⩽ _n_ ⩽ 10^9 ) — число рельс. Следующие строки
содержат запросы трех видов:

* I _a_ _b_ _D_ — изменение конфигурации. Рельсы с _a_-й по _b_-ю включительно после выполнения
запроса имеют подъем, равный _D_.

* Q _h_ — запуск вагонетки. Требуется найти число рельс, которое проедет вагонетка, которая
способна подняться на высоту _h_.

* E — конец ввода. Этот запрос встретится ровно один раз в конце файла.

В любой момент времени высота любой точки трека лежит в промежутке от 0 до 10^9. Во вводе
не более 100 000 строк.

### Формат выходных данных

Для каждого запроса Q выведите единственное целое число — количество рельс, которое проедет
вагонетка.

### Пример

**стандартный ввод**
```c++
4
Q 1
I 1 4 2
Q 3
Q 1
I 2 2 -
Q 3
E
```
**стандартный вывод**
```c++
4
1
0
3
```

### [Решение](I.cpp)

## J. Великая Китайская Стена

Имя входного файла: стандартный ввод

Имя выходного файла: стандартный вывод

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

В этой задаче мы проследим альтернативную историю Великой Китайской Стены.
Великая Китайская Стена состоит изnметровых участков, пронумерованных по порядку це
лыми числами от 1 до _n_. Каждый участок характеризуется своей высотой в метрах — целым неот
рицательным числом. До начала нашей истории Стена ещё не построена, поэтому высота каждого
участка равна нулю.
Происходят события двух видов.

1. УкреплениеСтены(запись: «defend _a_ _b_ _c_ »). Император вызывает к себе вассалов из пригра
    ничных провинций и велит им сделать так, чтобы промежуток Стены, охватывающий участки
    от _a_ до _b_ включительно, имел высоту не менее _c_ метров. Это значит, что все участки меньшей
    высоты на этом промежутке нужно достроить до высоты _c_, а остальные оставить нетронутыми.
    Приказ императора выполняется немедленно, то есть до наступления следующего события.
2. Нападениеварваров(запись: «attack _d_ _e_»). Варвары подходят к Стене снаружи и занимают
    позиции напротив промежутка Стены, охватывающего участки от _d_ до _e_ включительно. После
    этого они находят такой участок на этом промежутке, у которого высота как можно мень
    ше, и пытаются через него проникнуть на территорию Китая. Нападение также происходит
    немедленно, до наступления следующего события.

Для восстановления достоверной альтернативно-исторической картины не хватает одного: для
каждого нападения варваров указать минимальную высоту Стены на соответствующем промежутке,
а также какой-нибудь участок из этого промежутка с такой высотой. По заданной последователь-
ности событий найдите эти числа.

### Формат входных данных

В первой строке заданы через пробел два целых числа _n_ и _m_ — длина Стены в метрах и ко-
личество событий соответственно ( 1 ⩽ _n_ ⩽ 10^6 , 0 ⩽ _m_ ⩽ 10^5 ). В следующих _m_ строках описаны
события в порядке их следования. Если событие описывает укрепление Стены, оно задано в форме
«defend _a_ _b_ _c_» ( 1 ⩽ _a_ ⩽ _b_ ⩽ _n_, 1 ⩽ _c_ ⩽ 10^7 ). Если же событие описывает нападение варваров, оно
задано в форме «attack _d_ _e_» ( 1 ⩽ _d_ ⩽ _e_ ⩽ _n_).

### Формат выходных данных

В ответ на каждое нападение варваров выведите строку, содержащую два числа, разделённые
пробелом. Первое из этих чисел — минимальная высота Стены на соответствующем промежутке.
Второе — номер любого метрового участка Стены на этом промежутке, имеющего такую высоту.

### Пример

**стандартный ввод**
```c++
5 4
defend 1 3 10
attack 1 4
attack 2 3
attack 1 2
```

**стандартный вывод**
```c++
0 4
10 2
10 1
```

### [Решение](J.cpp)

## K. Перестановка

Имя входного файла: permutation.in

Имя выходного файла: permutation.out

Ограничение по времени: 0.5 секунд

Ограничение по памяти: 256 мегабайт

Отображение результатов: только полное решение подзадачи будет засчитано
На новый год Дед Мороз подарил НурлашКО большой массив целых чисел. Узнав это, его
учитель математики решил проверить, как хорошо он освоил одну из последних тем — перестановки.
Чтобы проверить это он спрашивает: «Образуют ли перестановку элементы массива c индексами
от _L_ до _R_ включительно?» Также иногда он может изменять некоторые числа. Напомним, что
перестановка из _n_ элементов — это упорядоченный набор, состоящий из чисел 1, 2,...,_n_. В нашем
случае _n_ = _R_ - _L_+ 1.
После новогодних контестов НурлашКО еще не пришел в себя. Поэтому он попросил вас о по-
мощи, чтобы не упасть в глазах своего учителя.

### Формат входных данных

Первая строка входного файла содержит число _N_( 1 ⩽ _N_ ⩽ 100 000). Во второй строке содер
жатся _N_ целых чисел _a1_, _a2_,...; _aN_( 1 ⩽ _ai_ ⩽ _N_). Третья строка входного файла содержит число _M_
( 1 ⩽ _M_ ⩽ 100 000), количество запросов учителя.
В каждой из следующих _M_ строк записано по три целых числа — _t_, _X_, _Y_ ( 1 ⩽ _t_ ⩽ 2 ,
1 ⩽ _X_, _Y_ ⩽ _N_). Если _t_ равно 1, то это запрос изменения элемента, в этом случае следует выполнить
присвоение _a_[X] = Y. Если _t_ равно 2, то следует проверить, является ли подотрезок с индексами от
 _X_ до _Y_ перестановкой, гарантируется что _X_ ⩽ _Y_.

### Формат выходных данных

Для каждого запроса второго типа в отдельной строке выведите **YES** если данный под отрезок
является перестановкой, иначе **NO**.

### Примеры

```c++
5
1 5 3 4 1
5
2 1 4
1 2 2
2 2 5
1 5 5
2 1 5
```

**permutation.out**
```c++
NO
YES
YES
```

### [Решение](K.cpp)

### Система оценки

Данная задача содержит шесть подзадач:

1. 1 ⩽ _N_, _M_ ⩽ 1000. Оценивается в 21 балл.
2. 1 ⩽ _N_, _M_ ⩽ 50 000. Оценивается в 28 баллов.
3. 1 ⩽ _N_, _M_ ⩽ 100 000, при этом во всех запросах _t_ = 2. Оценивается в 22 балла.
4. 1 ⩽ _N_, _M_ ⩽100 000. Оценивается в 29 баллов.

Подзадача 2 оценивается только в случае прохождения всех тестов подзадачи 1. Подзадача 4
оценивается только в случае прохождения всех тестов подзадач 1 и 2. Подзадача 3 оценивается
независимо.


## L. Парковка

Имя входного файла: parking.in

Имя выходного файла: parking.out

Ограничение по времени: 2 секунды

Ограничение по памяти: 256 мегабайт

Hа кольцевой парковке естьnмест пронумерованых от 1 до _n_. Есть два вида событий прибытие
машину на парковку и отъезд машины с парковки. Если машина приезжает на парковку, а её место
занято, то она едет далее по кругу и встаёт на первое свободное место.

### Формат входных данных

В первой строке входного файла находится два числа _n_ и _m_ — размер парковки и количество
запросов( 1 ⩽ _n_, _m_ ⩽ 100000 ). В следующих _m_ строках находятся события. Каждая из этих строк
имеет следующий вид:

* enter _x_ — приехала машина, которая хочет встать на место _x_. Для каждой такой команды
выведите какое место займёт эта машина.

* exit _x_ — уехала машина занимавшая место _x_. Гарантируется, что на этом месте была машина.

### Формат выходных данных

Выведите последовательно результаты выполнения всех операций enter.

### Пример

**parking.in**
```c++
3 5
enter 1
enter 1
exit 1
enter 2
enter 2
```

**parking.out**
```c++
1
2
3
1
```
